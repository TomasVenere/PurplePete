//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

using PurplePete.ConfluenceProvider.Contracts;

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace PurplePete.ConfluenceProvider.Clients
{
    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Client : ConfluenceProviderBase, IClient
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public Client(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://{your-domain}/wiki/api/v2";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Get Admin Key
        /// </summary>
        /// <remarks>
        /// Returns information about the admin key if one is currently enabled for the calling user within the site.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if an admin key is currently enabled for the calling user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AdminKeyResponse> GetAdminKeyAsync()
        {
            return GetAdminKeyAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Admin Key
        /// </summary>
        /// <remarks>
        /// Returns information about the admin key if one is currently enabled for the calling user within the site.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if an admin key is currently enabled for the calling user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AdminKeyResponse> GetAdminKeyAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "admin-key"
                    urlBuilder_.Append("admin-key");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdminKeyResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not currently have an admin key, if the calling user does not have permission to use admin keys, or if the site is not a Confluence Cloud Premium or Enterprise instance.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Enable Admin Key
        /// </summary>
        /// <remarks>
        /// Enables admin key access for the calling user within the site. If an admin key already exists for the user, a new one will be issued with an updated expiration time.
        /// <br/>
        /// <br/>**Note:** The `durationInMinutes` field within the request body is optional. If the request body is empty or if the `durationInMinutes` is set to 0 minutes, a new admin key will be issued to the calling user with a default duration of 10 minutes.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if a new admin key is successfully issued for the calling user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AdminKeyResponse> EnableAdminKeyAsync(object body)
        {
            return EnableAdminKeyAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Enable Admin Key
        /// </summary>
        /// <remarks>
        /// Enables admin key access for the calling user within the site. If an admin key already exists for the user, a new one will be issued with an updated expiration time.
        /// <br/>
        /// <br/>**Note:** The `durationInMinutes` field within the request body is optional. If the request body is empty or if the `durationInMinutes` is set to 0 minutes, a new admin key will be issued to the calling user with a default duration of 10 minutes.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if a new admin key is successfully issued for the calling user.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AdminKeyResponse> EnableAdminKeyAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "admin-key"
                    urlBuilder_.Append("admin-key");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdminKeyResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request body contains an invalid `durationInMinutes`.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to use admin keys or if the site is not a Confluence Cloud Premium or Enterprise instance.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Disable Admin Key
        /// </summary>
        /// <remarks>
        /// Disables admin key access for the calling user within the site.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if admin key access was successfully disabled for the calling user or if the user did not have an admin key in the first place.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DisableAdminKeyAsync()
        {
            return DisableAdminKeyAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Disable Admin Key
        /// </summary>
        /// <remarks>
        /// Disables admin key access for the calling user within the site.
        /// <br/>
        /// <br/>**[Permissions](https://support.atlassian.com/user-management/docs/give-users-admin-permissions/#Centralized-user-management-content) required**:
        /// <br/>User must be an organization or site admin.
        /// </remarks>
        /// <returns>Returned if admin key access was successfully disabled for the calling user or if the user did not have an admin key in the first place.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DisableAdminKeyAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "admin-key"
                    urlBuilder_.Append("admin-key");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to use admin keys or if the site is not a Confluence Cloud Premium or Enterprise instance.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachments
        /// </summary>
        /// <remarks>
        /// Returns all attachments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the container of the attachment.
        /// </remarks>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> GetAttachmentsAsync(AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous> status, string mediaType, string filename, int? limit)
        {
            return GetAttachmentsAsync(sort, cursor, status, mediaType, filename, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachments
        /// </summary>
        /// <remarks>
        /// Returns all attachments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the container of the attachment.
        /// </remarks>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> GetAttachmentsAsync(AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous> status, string mediaType, string filename, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments"
                    urlBuilder_.Append("attachments");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (mediaType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("mediaType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(mediaType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filename != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filename")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filename, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachment by id
        /// </summary>
        /// <remarks>
        /// Returns a specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment's container.
        /// </remarks>
        /// <param name="id">The ID of the attachment to be returned. If you don't know the attachment's ID, use Get attachments for page/blogpost/custom content.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this attachment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this attachment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_collaborators">Includes collaborators on the attachment.</param>
        /// <returns>Returned if the requested attachment is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response2> GetAttachmentByIdAsync(string id, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_versions, bool? include_version, bool? include_collaborators)
        {
            return GetAttachmentByIdAsync(id, version, include_labels, include_properties, include_operations, include_versions, include_version, include_collaborators, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachment by id
        /// </summary>
        /// <remarks>
        /// Returns a specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment's container.
        /// </remarks>
        /// <param name="id">The ID of the attachment to be returned. If you don't know the attachment's ID, use Get attachments for page/blogpost/custom content.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this attachment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this attachment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this attachment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_collaborators">Includes collaborators on the attachment.</param>
        /// <returns>Returned if the requested attachment is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> GetAttachmentByIdAsync(string id, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_versions, bool? include_version, bool? include_collaborators, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete attachment
        /// </summary>
        /// <remarks>
        /// Delete an attachment by id.
        /// <br/>
        /// <br/>Deleting an attachment moves the attachment to the trash, where it can be restored later. To permanently delete an attachment (or "purge" it),
        /// <br/>the endpoint must be called on a **trashed** attachment with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the container of the attachment.
        /// <br/>Permission to delete attachments in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the attachment to be deleted.</param>
        /// <param name="purge">If attempting to purge the attachment.</param>
        /// <returns>Returned if the attachment was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteAttachmentAsync(long id, bool? purge)
        {
            return DeleteAttachmentAsync(id, purge, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete attachment
        /// </summary>
        /// <remarks>
        /// Delete an attachment by id.
        /// <br/>
        /// <br/>Deleting an attachment moves the attachment to the trash, where it can be restored later. To permanently delete an attachment (or "purge" it),
        /// <br/>the endpoint must be called on a **trashed** attachment with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the container of the attachment.
        /// <br/>Permission to delete attachments in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the attachment to be deleted.</param>
        /// <param name="purge">If attempting to purge the attachment.</param>
        /// <returns>Returned if the attachment was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteAttachmentAsync(long id, bool? purge, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (purge != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("purge")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(purge, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided attachment does not exist\n- The user does not have permissions to view the container of the attachment\n- The user does not have the needed permissions to delete an attachment in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for attachment
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific attachment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the attachment and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response3> GetAttachmentLabelsAsync(long id, Prefix? prefix, string sort, string cursor, int? limit)
        {
            return GetAttachmentLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for attachment
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific attachment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the attachment and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response3> GetAttachmentLabelsAsync(long id, Prefix? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}/labels"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response3>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for attachment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetAttachmentOperationsAsync(string id)
        {
            return GetAttachmentOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for attachment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetAttachmentOperationsAsync(string id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}/operations"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for attachment
        /// </summary>
        /// <remarks>
        /// Retrieves all Content Properties tied to a specified attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response4> GetAttachmentContentPropertiesAsync(string attachment_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetAttachmentContentPropertiesAsync(attachment_id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for attachment
        /// </summary>
        /// <remarks>
        /// Retrieves all Content Properties tied to a specified attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response4> GetAttachmentContentPropertiesAsync(string attachment_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/properties"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response4>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for attachment
        /// </summary>
        /// <remarks>
        /// Creates a new content property for an attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateAttachmentPropertyAsync(string attachment_id, ContentPropertyCreateRequest body)
        {
            return CreateAttachmentPropertyAsync(attachment_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for attachment
        /// </summary>
        /// <remarks>
        /// Creates a new content property for an attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateAttachmentPropertyAsync(string attachment_id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/properties"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property to be returned</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetAttachmentContentPropertiesByIdAsync(string attachment_id, long property_id)
        {
            return GetAttachmentContentPropertiesByIdAsync(attachment_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property to be returned</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetAttachmentContentPropertiesByIdAsync(string attachment_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/properties/{property-id}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment,the attachment was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Update a content property for attachment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateAttachmentPropertyByIdAsync(string attachment_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateAttachmentPropertyByIdAsync(attachment_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Update a content property for attachment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateAttachmentPropertyByIdAsync(string attachment_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/properties/{property-id}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for an attachment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to attachment the page.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteAttachmentPropertyByIdAsync(string attachment_id, long property_id)
        {
            return DeleteAttachmentPropertyByIdAsync(attachment_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for attachment by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for an attachment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to attachment the page.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteAttachmentPropertyByIdAsync(string attachment_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/properties/{property-id}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment or the attachment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachment versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the attachment to be queried for its versions. If you don't know the attachment ID, use Get attachments and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested attachment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response5> GetAttachmentVersionsAsync(string id, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetAttachmentVersionsAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachment versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific attachment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the attachment to be queried for its versions. If you don't know the attachment ID, use Get attachments and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested attachment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response5> GetAttachmentVersionsAsync(string id, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}/versions"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response5>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for attachment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified attachment and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the attachment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetAttachmentVersionDetailsAsync(string attachment_id, long version_number)
        {
            return GetAttachmentVersionDetailsAsync(attachment_id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for attachment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified attachment and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment.
        /// </remarks>
        /// <param name="attachment_id">The ID of the attachment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the attachment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetAttachmentVersionDetailsAsync(string attachment_id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (attachment_id == null)
                throw new System.ArgumentNullException("attachment_id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{attachment-id}/versions/{version-number}"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(attachment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified attachment, the attachment was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachment comments
        /// </summary>
        /// <remarks>
        /// Returns the comments of the specific attachment.
        /// <br/>The number of results is limited by the `limit` parameter and additional results (if available) will be available through
        /// <br/>the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding containers.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="version">Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version.</param>
        /// <returns>Returned if the attachment comments were successfully retrieved</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response6> GetAttachmentCommentsAsync(string id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, CommentSortOrder? sort, long? version)
        {
            return GetAttachmentCommentsAsync(id, body_format, cursor, limit, sort, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachment comments
        /// </summary>
        /// <remarks>
        /// Returns the comments of the specific attachment.
        /// <br/>The number of results is limited by the `limit` parameter and additional results (if available) will be available through
        /// <br/>the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding containers.
        /// </remarks>
        /// <param name="id">The ID of the attachment for which comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="version">Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version.</param>
        /// <returns>Returned if the attachment comments were successfully retrieved</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response6> GetAttachmentCommentsAsync(string id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, CommentSortOrder? sort, long? version, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "attachments/{id}/footer-comments"
                    urlBuilder_.Append("attachments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/footer-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response6>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nattachment or associated containers.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog posts
        /// </summary>
        /// <remarks>
        /// Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only blog posts that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to blog posts based on their status. By default, `current` is used.</param>
        /// <param name="title">Filter the results to blog posts based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response7> GetBlogPostsAsync(System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, BlogPostSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous2> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit)
        {
            return GetBlogPostsAsync(id, space_id, sort, status, title, body_format, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog posts
        /// </summary>
        /// <remarks>
        /// Returns all blog posts. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only blog posts that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to blog posts based on their status. By default, `current` is used.</param>
        /// <param name="title">Filter the results to blog posts based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response7> GetBlogPostsAsync(System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, BlogPostSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous2> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts"
                    urlBuilder_.Append("blogposts");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                        foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response7>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create blog post
        /// </summary>
        /// <remarks>
        /// Creates a new blog post in the space specified by the spaceId.
        /// <br/>
        /// <br/>By default this will create the blog post as a non-draft, unless the status is specified as draft.
        /// <br/>If creating a non-draft, the title must not be empty.
        /// <br/>
        /// <br/>Currently only supports the storage representation specified in the body.representation enums below
        /// </remarks>
        /// <param name="private">The blog post will be private. Only the user who creates this blog post will have permission to view and edit one.</param>
        /// <returns>Returned if the blog post was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response8> CreateBlogPostAsync(bool? @private, object body)
        {
            return CreateBlogPostAsync(@private, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create blog post
        /// </summary>
        /// <remarks>
        /// Creates a new blog post in the space specified by the spaceId.
        /// <br/>
        /// <br/>By default this will create the blog post as a non-draft, unless the status is specified as draft.
        /// <br/>If creating a non-draft, the title must not be empty.
        /// <br/>
        /// <br/>Currently only supports the storage representation specified in the body.representation enums below
        /// </remarks>
        /// <param name="private">The blog post will be private. Only the user who creates this blog post will have permission to view and edit one.</param>
        /// <returns>Returned if the blog post was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response8> CreateBlogPostAsync(bool? @private, object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts"
                    urlBuilder_.Append("blogposts");
                    urlBuilder_.Append('?');
                    if (@private != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("private")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(@private, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response8>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if invalid values were passed in for any of the enums, a REQUIRED parameter was missing, or if the given title is a duplicate in the space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a blog post in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB)", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog post by id
        /// </summary>
        /// <remarks>
        /// Returns a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="get_draft">Retrieve the draft version of this blog post.</param>
        /// <param name="status">Filter the blog post being retrieved by its status.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this blog post in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this blog post in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_favorited_by_current_user_status">Includes whether this blog post has been favorited by the current user.</param>
        /// <param name="include_webresources">Includes web resources that can be used to render blog post content on a client.</param>
        /// <param name="include_collaborators">Includes collaborators on the blog post.</param>
        /// <returns>Returned if the requested blog post is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response9> GetBlogPostByIdAsync(long id, PrimaryBodyRepresentationSingle? body_format, bool? get_draft, System.Collections.Generic.IEnumerable<Anonymous3> status, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, bool? include_favorited_by_current_user_status, bool? include_webresources, bool? include_collaborators)
        {
            return GetBlogPostByIdAsync(id, body_format, get_draft, status, version, include_labels, include_properties, include_operations, include_likes, include_versions, include_version, include_favorited_by_current_user_status, include_webresources, include_collaborators, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog post by id
        /// </summary>
        /// <remarks>
        /// Returns a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be returned. If you don't know the blog post ID, use Get blog posts and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="get_draft">Retrieve the draft version of this blog post.</param>
        /// <param name="status">Filter the blog post being retrieved by its status.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this blog post in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this blog post in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this blog post in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_favorited_by_current_user_status">Includes whether this blog post has been favorited by the current user.</param>
        /// <param name="include_webresources">Includes web resources that can be used to render blog post content on a client.</param>
        /// <param name="include_collaborators">Includes collaborators on the blog post.</param>
        /// <returns>Returned if the requested blog post is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response9> GetBlogPostByIdAsync(long id, PrimaryBodyRepresentationSingle? body_format, bool? get_draft, System.Collections.Generic.IEnumerable<Anonymous3> status, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, bool? include_favorited_by_current_user_status, bool? include_webresources, bool? include_collaborators, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (get_draft != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("get-draft")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(get_draft, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_likes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-likes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_likes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_favorited_by_current_user_status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-favorited-by-current-user-status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_favorited_by_current_user_status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_webresources != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-webresources")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_webresources, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response9>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update blog post
        /// </summary>
        /// <remarks>
        /// Update a blog post by id.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results.</param>
        /// <returns>Returned if the requested blog post is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response10> UpdateBlogPostAsync(long id, object body)
        {
            return UpdateBlogPostAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update blog post
        /// </summary>
        /// <remarks>
        /// Update a blog post by id.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be updated. If you don't know the blog post ID, use Get Blog Posts and filter the results.</param>
        /// <returns>Returned if the requested blog post is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response10> UpdateBlogPostAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response10>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided blog post does not exist\n- The user does not have permissions to view the blog post\n- The user does not have the needed permissions to update a blog post in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete blog post
        /// </summary>
        /// <remarks>
        /// Delete a blog post by id.
        /// <br/>
        /// <br/>By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a 
        /// <br/>draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
        /// <br/>
        /// <br/>Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later.
        /// <br/>To permanently delete a blog post (or "purge" it), the endpoint must be called on a **trashed** blog post with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// <br/>Permission to delete blog posts in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the blog post to be deleted.</param>
        /// <param name="purge">If attempting to purge the blog post.</param>
        /// <param name="draft">If attempting to delete a blog post that is a draft.</param>
        /// <returns>Returned if the blog post was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteBlogPostAsync(long id, bool? purge, bool? draft)
        {
            return DeleteBlogPostAsync(id, purge, draft, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete blog post
        /// </summary>
        /// <remarks>
        /// Delete a blog post by id.
        /// <br/>
        /// <br/>By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a 
        /// <br/>draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
        /// <br/>
        /// <br/>Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later.
        /// <br/>To permanently delete a blog post (or "purge" it), the endpoint must be called on a **trashed** blog post with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// <br/>Permission to delete blog posts in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the blog post to be deleted.</param>
        /// <param name="purge">If attempting to purge the blog post.</param>
        /// <param name="draft">If attempting to delete a blog post that is a draft.</param>
        /// <returns>Returned if the blog post was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteBlogPostAsync(long id, bool? purge, bool? draft, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (purge != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("purge")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(purge, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (draft != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("draft")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(draft, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided blog post does not exist\n- The user does not have permissions to view the blog post\n- The user does not have the needed permissions to delete a blog post in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response11> GetBlogpostAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous4> status, string mediaType, string filename, int? limit)
        {
            return GetBlogpostAttachmentsAsync(id, sort, cursor, status, mediaType, filename, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response11> GetBlogpostAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous4> status, string mediaType, string filename, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/attachments"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attachments");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (mediaType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("mediaType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(mediaType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filename != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filename")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filename, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response11>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content by type in blog post
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response12> GetCustomContentByTypeInBlogPostAsync(long id, string type, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format)
        {
            return GetCustomContentByTypeInBlogPostAsync(id, type, sort, cursor, limit, body_format, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content by type in blog post
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given blogpost. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response12> GetCustomContentByTypeInBlogPostAsync(long id, string type, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/custom-content"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/custom-content");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response12>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the given blog post is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for blog post
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response13> GetBlogPostLabelsAsync(long id, Prefix2? prefix, string sort, string cursor, int? limit)
        {
            return GetBlogPostLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for blog post
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response13> GetBlogPostLabelsAsync(long id, Prefix2? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/labels"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response13>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get like count for blog post
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Integer> GetBlogPostLikeCountAsync(long id)
        {
            return GetBlogPostLikeCountAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get like count for blog post
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Integer> GetBlogPostLikeCountAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/likes/count"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/count");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Integer>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get account IDs of likes for blog post
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which account IDs should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response14> GetBlogPostLikeUsersAsync(long id, string cursor, int? limit)
        {
            return GetBlogPostLikeUsersAsync(id, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get account IDs of likes for blog post
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which account IDs should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response14> GetBlogPostLikeUsersAsync(long id, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/likes/users"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/users");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response14>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for blog post
        /// </summary>
        /// <remarks>
        /// Retrieves all Content Properties tied to a specified blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response15> GetBlogpostContentPropertiesAsync(long blogpost_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetBlogpostContentPropertiesAsync(blogpost_id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for blog post
        /// </summary>
        /// <remarks>
        /// Retrieves all Content Properties tied to a specified blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response15> GetBlogpostContentPropertiesAsync(long blogpost_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/properties"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response15>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for blog post
        /// </summary>
        /// <remarks>
        /// Creates a new property for a blogpost.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateBlogpostPropertyAsync(long blogpost_id, ContentPropertyCreateRequest body)
        {
            return CreateBlogpostPropertyAsync(blogpost_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for blog post
        /// </summary>
        /// <remarks>
        /// Creates a new property for a blogpost.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateBlogpostPropertyAsync(long blogpost_id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/properties"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for blog post by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the property being requested</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetBlogpostContentPropertiesByIdAsync(long blogpost_id, long property_id)
        {
            return GetBlogpostContentPropertiesByIdAsync(blogpost_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for blog post by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the property being requested</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetBlogpostContentPropertiesByIdAsync(long blogpost_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/properties/{property-id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post,the blog post was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for blog post by id
        /// </summary>
        /// <remarks>
        /// Update a content property for blog post by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateBlogpostPropertyByIdAsync(long blogpost_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateBlogpostPropertyByIdAsync(blogpost_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for blog post by id
        /// </summary>
        /// <remarks>
        /// Update a content property for blog post by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateBlogpostPropertyByIdAsync(long blogpost_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/properties/{property-id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for blogpost by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a blogpost by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteBlogpostPropertyByIdAsync(long blogpost_id, long property_id)
        {
            return DeleteBlogpostPropertyByIdAsync(blogpost_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for blogpost by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a blogpost by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteBlogpostPropertyByIdAsync(long blogpost_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/properties/{property-id}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for blog post
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetBlogPostOperationsAsync(long id)
        {
            return GetBlogPostOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for blog post
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetBlogPostOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/operations"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog post versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific blog post. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be queried for its versions. If you don't know the blog post ID, use Get blog posts and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested blog post versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response16> GetBlogPostVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetBlogPostVersionsAsync(id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog post versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific blog post. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post to be queried for its versions. If you don't know the blog post ID, use Get blog posts and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested blog post versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response16> GetBlogPostVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/versions"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response16>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for blog post version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified blog post and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which version details should be returned.</param>
        /// <param name="version_number">The version number of the blog post to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetBlogPostVersionDetailsAsync(long blogpost_id, long version_number)
        {
            return GetBlogPostVersionDetailsAsync(blogpost_id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for blog post version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified blog post and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the blog post.
        /// </remarks>
        /// <param name="blogpost_id">The ID of the blog post for which version details should be returned.</param>
        /// <param name="version_number">The version number of the blog post to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetBlogPostVersionDetailsAsync(long blogpost_id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (blogpost_id == null)
                throw new System.ArgumentNullException("blogpost_id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{blogpost-id}/versions/{version-number}"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(blogpost_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified blog post, the blog post was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Convert content ids to content types
        /// </summary>
        /// <remarks>
        /// Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2
        /// <br/>who may have stored just content ids without their associated type. This will return types as they should be used in v2.
        /// <br/>Notably, this will return `inline-comment` for inline comments and `footer-comment` for footer comments, which is distinct from them
        /// <br/>both being represented by `comment` in v1.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to `null` in the response.
        /// </remarks>
        /// <returns>Returned if the requested content ids are successfully converted to their content types</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentIdToContentTypeResponse> ConvertContentIdsToContentTypesAsync(object body)
        {
            return ConvertContentIdsToContentTypesAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Convert content ids to content types
        /// </summary>
        /// <remarks>
        /// Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2
        /// <br/>who may have stored just content ids without their associated type. This will return types as they should be used in v2.
        /// <br/>Notably, this will return `inline-comment` for inline comments and `footer-comment` for footer comments, which is distinct from them
        /// <br/>both being represented by `comment` in v1.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to `null` in the response.
        /// </remarks>
        /// <returns>Returned if the requested content ids are successfully converted to their content types</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentIdToContentTypeResponse> ConvertContentIdsToContentTypesAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "content/convert-ids-to-types"
                    urlBuilder_.Append("content/convert-ids-to-types");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentIdToContentTypeResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content by type
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
        /// </remarks>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="id">Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response17> GetCustomContentByTypeAsync(string type, System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format)
        {
            return GetCustomContentByTypeAsync(type, id, space_id, sort, cursor, limit, body_format, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content by type
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
        /// </remarks>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="id">Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response17> GetCustomContentByTypeAsync(string type, System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format, System.Threading.CancellationToken cancellationToken)
        {
            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content"
                    urlBuilder_.Append("custom-content");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (id != null)
                    {
                        foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response17>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create custom content
        /// </summary>
        /// <remarks>
        /// Creates a new custom content in the given space, page, blogpost or other custom content.
        /// <br/>
        /// <br/>Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.
        /// </remarks>
        /// <returns>Returned if the requested custom content is created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response18> CreateCustomContentAsync(object body)
        {
            return CreateCustomContentAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create custom content
        /// </summary>
        /// <remarks>
        /// Creates a new custom content in the given space, page, blogpost or other custom content.
        /// <br/>
        /// <br/>Only one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is required in the request body.
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.
        /// </remarks>
        /// <returns>Returned if the requested custom content is created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response18> CreateCustomContentAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content"
                    urlBuilder_.Append("custom-content");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response18>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the type of custom content is not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content by id
        /// </summary>
        /// <remarks>
        /// Returns a specific piece of custom content. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
        /// </remarks>
        /// <param name="id">The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this custom content in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this custom content in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_collaborators">Includes collaborators on the custom content.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response19> GetCustomContentByIdAsync(long id, CustomContentBodyRepresentationSingle? body_format, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_versions, bool? include_version, bool? include_collaborators)
        {
            return GetCustomContentByIdAsync(id, body_format, version, include_labels, include_properties, include_operations, include_versions, include_version, include_collaborators, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content by id
        /// </summary>
        /// <remarks>
        /// Returns a specific piece of custom content. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
        /// </remarks>
        /// <param name="id">The ID of the custom content to be returned. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this custom content in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this custom content in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this custom content in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_collaborators">Includes collaborators on the custom content.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response19> GetCustomContentByIdAsync(long id, CustomContentBodyRepresentationSingle? body_format, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_versions, bool? include_version, bool? include_collaborators, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response19>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update custom content
        /// </summary>
        /// <remarks>
        /// Update a custom content by id.
        /// <br/>At most one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
        /// <br/>Note that if `spaceId` is specified, it must be the same as the `spaceId` used for creating the custom content
        /// <br/>as moving custom content to a different space is not supported.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.
        /// </remarks>
        /// <param name="id">The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.</param>
        /// <returns>Returned if the requested custom content is updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response20> UpdateCustomContentAsync(long id, object body)
        {
            return UpdateCustomContentAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update custom content
        /// </summary>
        /// <remarks>
        /// Update a custom content by id.
        /// <br/>At most one of `spaceId`, `pageId`, `blogPostId`, or `customContentId` is allowed in the request body.
        /// <br/>Note that if `spaceId` is specified, it must be the same as the `spaceId` used for creating the custom content
        /// <br/>as moving custom content to a different space is not supported.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.
        /// </remarks>
        /// <param name="id">The ID of the custom content to be updated. If you don't know the custom content ID, use Get Custom Content by Type and filter the results.</param>
        /// <returns>Returned if the requested custom content is updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response20> UpdateCustomContentAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response20>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the type of custom content is not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete custom content
        /// </summary>
        /// <remarks>
        /// Delete a custom content by id.
        /// <br/>
        /// <br/>Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport.
        /// <br/>To permanently delete a **trashed** custom content, the endpoint must be called with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space.
        /// <br/>Permission to delete custom content in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the custom content to be deleted.</param>
        /// <param name="purge">If attempting to purge the custom content.</param>
        /// <returns>Returned if the custom content was deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteCustomContentAsync(long id, bool? purge)
        {
            return DeleteCustomContentAsync(id, purge, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete custom content
        /// </summary>
        /// <remarks>
        /// Delete a custom content by id.
        /// <br/>
        /// <br/>Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport.
        /// <br/>To permanently delete a **trashed** custom content, the endpoint must be called with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space.
        /// <br/>Permission to delete custom content in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the custom content to be deleted.</param>
        /// <param name="purge">If attempting to purge the custom content.</param>
        /// <returns>Returned if the custom content was deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteCustomContentAsync(long id, bool? purge, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (purge != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("purge")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(purge, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the custom content is not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachments for custom content
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific custom content. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the custom content and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response21> GetCustomContentAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous5> status, string mediaType, string filename, int? limit)
        {
            return GetCustomContentAttachmentsAsync(id, sort, cursor, status, mediaType, filename, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachments for custom content
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific custom content. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the custom content and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response21> GetCustomContentAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous5> status, string mediaType, string filename, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}/attachments"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attachments");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (mediaType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("mediaType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(mediaType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filename != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filename")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filename, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response21>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content comments
        /// </summary>
        /// <remarks>
        /// Returns the comments of the specific custom content.
        /// <br/>The number of results is limited by the `limit` parameter and additional results (if available) will be available through
        /// <br/>the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding containers.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the custom content comments were successfully retrieved</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response22> GetCustomContentCommentsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, CommentSortOrder? sort)
        {
            return GetCustomContentCommentsAsync(id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content comments
        /// </summary>
        /// <remarks>
        /// Returns the comments of the specific custom content.
        /// <br/>The number of results is limited by the `limit` parameter and additional results (if available) will be available through
        /// <br/>the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding containers.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the custom content comments were successfully retrieved</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response22> GetCustomContentCommentsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, CommentSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}/footer-comments"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/footer-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response22>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\ncustom content or associated containers.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for custom content
        /// </summary>
        /// <remarks>
        /// Returns the labels for a specific piece of custom content. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response23> GetCustomContentLabelsAsync(long id, Prefix3? prefix, string sort, string cursor, int? limit)
        {
            return GetCustomContentLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for custom content
        /// </summary>
        /// <remarks>
        /// Returns the labels for a specific piece of custom content. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response23> GetCustomContentLabelsAsync(long id, Prefix3? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}/labels"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response23>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for custom content
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the custom content and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetCustomContentOperationsAsync(long id)
        {
            return GetCustomContentOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for custom content
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the custom content and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the custom content for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetCustomContentOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}/operations"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for custom content
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response24> GetCustomContentContentPropertiesAsync(long custom_content_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetCustomContentContentPropertiesAsync(custom_content_id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for custom content
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response24> GetCustomContentContentPropertiesAsync(long custom_content_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/properties"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response24>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for custom content
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a piece of custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateCustomContentPropertyAsync(long custom_content_id, ContentPropertyCreateRequest body)
        {
            return CreateCustomContentPropertyAsync(custom_content_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for custom content
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a piece of custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateCustomContentPropertyAsync(long custom_content_id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/properties"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetCustomContentContentPropertiesByIdAsync(long custom_content_id, long property_id)
        {
            return GetCustomContentContentPropertiesByIdAsync(custom_content_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetCustomContentContentPropertiesByIdAsync(long custom_content_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/properties/{property-id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content, the custom content was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a piece of custom content by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateCustomContentPropertyByIdAsync(long custom_content_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateCustomContentPropertyByIdAsync(custom_content_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a piece of custom content by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateCustomContentPropertyByIdAsync(long custom_content_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/properties/{property-id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a piece of custom content by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteCustomContentPropertyByIdAsync(long custom_content_id, long property_id)
        {
            return DeleteCustomContentPropertyByIdAsync(custom_content_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for custom content by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a piece of custom content by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the custom content.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteCustomContentPropertyByIdAsync(long custom_content_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/properties/{property-id}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels
        /// </summary>
        /// <remarks>
        /// Returns all labels. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="label_id">Filters on label ID. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="prefix">Filters on label prefix. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response25> GetLabelsAsync(System.Collections.Generic.IEnumerable<long> label_id, System.Collections.Generic.IEnumerable<string> prefix, string cursor, string sort, int? limit)
        {
            return GetLabelsAsync(label_id, prefix, cursor, sort, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels
        /// </summary>
        /// <remarks>
        /// Returns all labels. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="label_id">Filters on label ID. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="prefix">Filters on label prefix. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response25> GetLabelsAsync(System.Collections.Generic.IEnumerable<long> label_id, System.Collections.Generic.IEnumerable<string> prefix, string cursor, string sort, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "labels"
                    urlBuilder_.Append("labels");
                    urlBuilder_.Append('?');
                    if (label_id != null)
                    {
                        foreach (var item_ in label_id) { urlBuilder_.Append(System.Uri.EscapeDataString("label-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (prefix != null)
                    {
                        foreach (var item_ in prefix) { urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response25>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachments for label
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response26> GetLabelAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, int? limit)
        {
            return GetLabelAttachmentsAsync(id, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachments for label
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the attachment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response26> GetLabelAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "labels/{id}/attachments"
                    urlBuilder_.Append("labels/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attachments");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response26>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested label or label was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog posts for label
        /// </summary>
        /// <remarks>
        /// Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which blog posts should be returned.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response27> GetLabelBlogPostsAsync(long id, System.Collections.Generic.IEnumerable<long> space_id, PrimaryBodyRepresentation? body_format, BlogPostSortOrder? sort, string cursor, int? limit)
        {
            return GetLabelBlogPostsAsync(id, space_id, body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog posts for label
        /// </summary>
        /// <remarks>
        /// Returns the blogposts of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which blog posts should be returned.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response27> GetLabelBlogPostsAsync(long id, System.Collections.Generic.IEnumerable<long> space_id, PrimaryBodyRepresentation? body_format, BlogPostSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "labels/{id}/blogposts"
                    urlBuilder_.Append("labels/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/blogposts");
                    urlBuilder_.Append('?');
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response27>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested label or label was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get pages for label
        /// </summary>
        /// <remarks>
        /// Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which pages should be returned.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response28> GetLabelPagesAsync(long id, System.Collections.Generic.IEnumerable<long> space_id, PrimaryBodyRepresentation? body_format, PageSortOrder? sort, string cursor, int? limit)
        {
            return GetLabelPagesAsync(id, space_id, body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get pages for label
        /// </summary>
        /// <remarks>
        /// Returns the pages of specified label. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the label for which pages should be returned.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages for specified label were successfully fetched.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response28> GetLabelPagesAsync(long id, System.Collections.Generic.IEnumerable<long> space_id, PrimaryBodyRepresentation? body_format, PageSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "labels/{id}/pages"
                    urlBuilder_.Append("labels/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/pages");
                    urlBuilder_.Append('?');
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response28>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested label or label was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get pages
        /// </summary>
        /// <remarks>
        /// Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to pages based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="title">Filter the results to pages based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response29> GetPagesAsync(System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, PageSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous6> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit)
        {
            return GetPagesAsync(id, space_id, sort, status, title, body_format, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get pages
        /// </summary>
        /// <remarks>
        /// Returns all pages. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.</param>
        /// <param name="space_id">Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to pages based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="title">Filter the results to pages based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response29> GetPagesAsync(System.Collections.Generic.IEnumerable<long> id, System.Collections.Generic.IEnumerable<long> space_id, PageSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous6> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages"
                    urlBuilder_.Append("pages");
                    urlBuilder_.Append('?');
                    if (id != null)
                    {
                        foreach (var item_ in id) { urlBuilder_.Append(System.Uri.EscapeDataString("id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response29>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create page
        /// </summary>
        /// <remarks>
        /// Creates a page in the space.
        /// <br/>
        /// <br/>Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a page in the space.
        /// </remarks>
        /// <param name="embedded">Tag the content as embedded and content will be created in NCS.</param>
        /// <param name="private">The page will be private. Only the user who creates this page will have permission to view and edit one.</param>
        /// <param name="root_level">The page will be created at the root level of the space (outside the space homepage tree). If true, then a 
        /// <br/>value may not be supplied for the `parentId` body parameter.</param>
        /// <returns>Returned if the page was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response30> CreatePageAsync(bool? embedded, bool? @private, bool? root_level, object body)
        {
            return CreatePageAsync(embedded, @private, root_level, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create page
        /// </summary>
        /// <remarks>
        /// Creates a page in the space.
        /// <br/>
        /// <br/>Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a page in the space.
        /// </remarks>
        /// <param name="embedded">Tag the content as embedded and content will be created in NCS.</param>
        /// <param name="private">The page will be private. Only the user who creates this page will have permission to view and edit one.</param>
        /// <param name="root_level">The page will be created at the root level of the space (outside the space homepage tree). If true, then a 
        /// <br/>value may not be supplied for the `parentId` body parameter.</param>
        /// <returns>Returned if the page was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response30> CreatePageAsync(bool? embedded, bool? @private, bool? root_level, object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages"
                    urlBuilder_.Append("pages");
                    urlBuilder_.Append('?');
                    if (embedded != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("embedded")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(embedded, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (@private != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("private")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(@private, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (root_level != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("root-level")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(root_level, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response30>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a page in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get page by id
        /// </summary>
        /// <remarks>
        /// Returns a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="get_draft">Retrieve the draft version of this page.</param>
        /// <param name="status">Filter the page being retrieved by its status.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this page in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this page in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_favorited_by_current_user_status">Includes whether this page has been favorited by the current user.</param>
        /// <param name="include_webresources">Includes web resources that can be used to render page content on a client.</param>
        /// <param name="include_collaborators">Includes collaborators on the page.</param>
        /// <param name="include_direct_children">Includes direct children of the page, as defined in the `ChildrenResponse` object.</param>
        /// <returns>Returned if the requested page is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response31> GetPageByIdAsync(long id, PrimaryBodyRepresentationSingle? body_format, bool? get_draft, System.Collections.Generic.IEnumerable<Anonymous7> status, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, bool? include_favorited_by_current_user_status, bool? include_webresources, bool? include_collaborators, bool? include_direct_children)
        {
            return GetPageByIdAsync(id, body_format, get_draft, status, version, include_labels, include_properties, include_operations, include_likes, include_versions, include_version, include_favorited_by_current_user_status, include_webresources, include_collaborators, include_direct_children, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get page by id
        /// </summary>
        /// <remarks>
        /// Returns a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page to be returned. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="get_draft">Retrieve the draft version of this page.</param>
        /// <param name="status">Filter the page being retrieved by its status.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_labels">Includes labels associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this page in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this page in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this page in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <param name="include_favorited_by_current_user_status">Includes whether this page has been favorited by the current user.</param>
        /// <param name="include_webresources">Includes web resources that can be used to render page content on a client.</param>
        /// <param name="include_collaborators">Includes collaborators on the page.</param>
        /// <param name="include_direct_children">Includes direct children of the page, as defined in the `ChildrenResponse` object.</param>
        /// <returns>Returned if the requested page is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response31> GetPageByIdAsync(long id, PrimaryBodyRepresentationSingle? body_format, bool? get_draft, System.Collections.Generic.IEnumerable<Anonymous7> status, int? version, bool? include_labels, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, bool? include_favorited_by_current_user_status, bool? include_webresources, bool? include_collaborators, bool? include_direct_children, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (get_draft != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("get-draft")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(get_draft, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_likes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-likes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_likes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_favorited_by_current_user_status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-favorited-by-current-user-status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_favorited_by_current_user_status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_webresources != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-webresources")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_webresources, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_direct_children != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-direct-children")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_direct_children, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response31>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update page
        /// </summary>
        /// <remarks>
        /// Update a page by id.
        /// <br/>
        /// <br/>When the "current" version is updated, the provided body content is considered as the latest version. This latest body content
        /// <br/>will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged, 
        /// <br/>the latest provided content may entirely override what was previously in the draft. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space. Permission to update pages in the space.
        /// </remarks>
        /// <param name="id">The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results.</param>
        /// <returns>Returned if the requested page is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response32> UpdatePageAsync(long id, object body)
        {
            return UpdatePageAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update page
        /// </summary>
        /// <remarks>
        /// Update a page by id.
        /// <br/>
        /// <br/>When the "current" version is updated, the provided body content is considered as the latest version. This latest body content
        /// <br/>will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged, 
        /// <br/>the latest provided content may entirely override what was previously in the draft. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space. Permission to update pages in the space.
        /// </remarks>
        /// <param name="id">The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results.</param>
        /// <returns>Returned if the requested page is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response32> UpdatePageAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response32>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided page does not exist\n- The user does not have permissions to view the page\n- The user does not have the needed permissions to update a page in the space\n- The user provides a parentId for a page that does not exist or they do not have permission to view\n- There are no spaces associated with the given spaceId", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete page
        /// </summary>
        /// <remarks>
        /// Delete a page by id.
        /// <br/>
        /// <br/>By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a 
        /// <br/>draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
        /// <br/>
        /// <br/>Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or "purge" it),
        /// <br/>the endpoint must be called on a **trashed** page with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// <br/>Permission to delete pages in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the page to be deleted.</param>
        /// <param name="purge">If attempting to purge the page.</param>
        /// <param name="draft">If attempting to delete a page that is a draft.</param>
        /// <returns>Returned if the page was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeletePageAsync(long id, bool? purge, bool? draft)
        {
            return DeletePageAsync(id, purge, draft, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete page
        /// </summary>
        /// <remarks>
        /// Delete a page by id.
        /// <br/>
        /// <br/>By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a 
        /// <br/>draft with the following param `draft=true`. Discarded drafts are not sent to the trash and are permanently deleted.
        /// <br/>
        /// <br/>Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or "purge" it),
        /// <br/>the endpoint must be called on a **trashed** page with the following param `purge=true`.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// <br/>Permission to delete pages in the space.
        /// <br/>Permission to administer the space (if attempting to purge).
        /// </remarks>
        /// <param name="id">The ID of the page to be deleted.</param>
        /// <param name="purge">If attempting to purge the page.</param>
        /// <param name="draft">If attempting to delete a page that is a draft.</param>
        /// <returns>Returned if the page was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeletePageAsync(long id, bool? purge, bool? draft, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (purge != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("purge")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(purge, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (draft != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("draft")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(draft, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided page does not exist\n- The user does not have permissions to view the page\n- The user does not have the needed permissions to delete a page in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get attachments for page
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response33> GetPageAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous8> status, string mediaType, string filename, int? limit)
        {
            return GetPageAttachmentsAsync(id, sort, cursor, status, mediaType, filename, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get attachments for page
        /// </summary>
        /// <remarks>
        /// Returns the attachments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which attachments should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="status">Filter the results to attachments based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="mediaType">Filters on the mediaType of attachments. Only one may be specified.</param>
        /// <param name="filename">Filters on the file-name of attachments. Only one may be specified.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested attachments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response33> GetPageAttachmentsAsync(long id, AttachmentSortOrder? sort, string cursor, System.Collections.Generic.IEnumerable<Anonymous8> status, string mediaType, string filename, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/attachments"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/attachments");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (mediaType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("mediaType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(mediaType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filename != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filename")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filename, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response33>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content by type in page
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content (page), and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response34> GetCustomContentByTypeInPageAsync(long id, string type, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format)
        {
            return GetCustomContentByTypeInPageAsync(id, type, sort, cursor, limit, body_format, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content by type in page
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content, the container of the custom content (page), and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response34> GetCustomContentByTypeInPageAsync(long id, string type, CustomContentSortOrder? sort, string cursor, int? limit, CustomContentBodyRepresentation? body_format, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/custom-content"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/custom-content");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response34>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the given page is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for page
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the page for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response35> GetPageLabelsAsync(long id, Prefix4? prefix, string sort, string cursor, int? limit)
        {
            return GetPageLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for page
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the page for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response35> GetPageLabelsAsync(long id, Prefix4? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/labels"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response35>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get like count for page
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Anonymous17> GetPageLikeCountAsync(long id)
        {
            return GetPageLikeCountAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get like count for page
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Anonymous17> GetPageLikeCountAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/likes/count"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/count");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Anonymous17>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get account IDs of likes for page
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response36> GetPageLikeUsersAsync(long id, string cursor, int? limit)
        {
            return GetPageLikeUsersAsync(id, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get account IDs of likes for page
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response36> GetPageLikeUsersAsync(long id, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/likes/users"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/users");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response36>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for page
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetPageOperationsAsync(long id)
        {
            return GetPageOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for page
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetPageOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/operations"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for page
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response37> GetPageContentPropertiesAsync(long page_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetPageContentPropertiesAsync(page_id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for page
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response37> GetPageContentPropertiesAsync(long page_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/properties"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response37>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for page
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreatePagePropertyAsync(long page_id, ContentPropertyCreateRequest body)
        {
            return CreatePagePropertyAsync(page_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for page
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreatePagePropertyAsync(long page_id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/properties"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for page by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetPageContentPropertiesByIdAsync(long page_id, long property_id)
        {
            return GetPageContentPropertiesByIdAsync(page_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for page by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetPageContentPropertiesByIdAsync(long page_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/properties/{property-id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page, the page was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for page by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a page by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdatePagePropertyByIdAsync(long page_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdatePagePropertyByIdAsync(page_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for page by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a page by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdatePagePropertyByIdAsync(long page_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/properties/{property-id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for page by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a page by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeletePagePropertyByIdAsync(long page_id, long property_id)
        {
            return DeletePagePropertyByIdAsync(page_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for page by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a page by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeletePagePropertyByIdAsync(long page_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/properties/{property-id}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update page title
        /// </summary>
        /// <remarks>
        /// Updates the title of a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space. Permission to update pages in the space.
        /// </remarks>
        /// <param name="id">The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results</param>
        /// <returns>Returned if the requested page is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response38> UpdatePageTitleAsync(long id, object body)
        {
            return UpdatePageTitleAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update page title
        /// </summary>
        /// <remarks>
        /// Updates the title of a specified page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space. Permission to update pages in the space.
        /// </remarks>
        /// <param name="id">The ID of the page to be updated. If you don't know the page ID, use Get Pages and filter the results</param>
        /// <returns>Returned if the requested page is successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response38> UpdatePageTitleAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/title"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/title");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response38>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided page does not exist\n- The user does not have permissions to view the page\n- The user does not have the needed permissions to update a page in the space\n- The user provides a parentId for a page that does not exist or they do not have permission to view\n- There are no spaces associated with the given spaceId", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get page versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page to be queried for its versions. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested page versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response39> GetPageVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetPageVersionsAsync(id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get page versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page to be queried for its versions. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested page versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response39> GetPageVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/versions"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response39>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create whiteboard
        /// </summary>
        /// <remarks>
        /// Creates a whiteboard in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a whiteboard in the space.
        /// </remarks>
        /// <param name="private">The whiteboard will be private. Only the user who creates this whiteboard will have permission to view and edit one.</param>
        /// <returns>Returned if the whiteboard was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response40> CreateWhiteboardAsync(bool? @private, object body)
        {
            return CreateWhiteboardAsync(@private, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create whiteboard
        /// </summary>
        /// <remarks>
        /// Creates a whiteboard in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a whiteboard in the space.
        /// </remarks>
        /// <param name="private">The whiteboard will be private. Only the user who creates this whiteboard will have permission to view and edit one.</param>
        /// <returns>Returned if the whiteboard was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response40> CreateWhiteboardAsync(bool? @private, object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards"
                    urlBuilder_.Append("whiteboards");
                    urlBuilder_.Append('?');
                    if (@private != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("private")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(@private, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response40>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a whiteboard in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get whiteboard by id
        /// </summary>
        /// <remarks>
        /// Returns a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to be returned</param>
        /// <param name="include_collaborators">Includes collaborators on the whiteboard.</param>
        /// <param name="include_direct_children">Includes direct children of the whiteboard, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this whiteboard in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this whiteboard in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested whiteboard is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response41> GetWhiteboardByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties)
        {
            return GetWhiteboardByIdAsync(id, include_collaborators, include_direct_children, include_operations, include_properties, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get whiteboard by id
        /// </summary>
        /// <remarks>
        /// Returns a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to be returned</param>
        /// <param name="include_collaborators">Includes collaborators on the whiteboard.</param>
        /// <param name="include_direct_children">Includes direct children of the whiteboard, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this whiteboard in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this whiteboard in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested whiteboard is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response41> GetWhiteboardByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_direct_children != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-direct-children")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_direct_children, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response41>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete whiteboard
        /// </summary>
        /// <remarks>
        /// Delete a whiteboard by id.
        /// <br/>
        /// <br/>Deleting a whiteboard moves the whiteboard to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// <br/>Permission to delete whiteboards in the space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to be deleted.</param>
        /// <returns>Returned if the whiteboard was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteWhiteboardAsync(long id)
        {
            return DeleteWhiteboardAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete whiteboard
        /// </summary>
        /// <remarks>
        /// Delete a whiteboard by id.
        /// <br/>
        /// <br/>Deleting a whiteboard moves the whiteboard to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// <br/>Permission to delete whiteboards in the space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to be deleted.</param>
        /// <returns>Returned if the whiteboard was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteWhiteboardAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided whiteboard does not exist\n- The user does not have permissions to view the whiteboard\n- The user does not have the needed permissions to delete a whiteboard in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for whiteboard
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response42> GetWhiteboardContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetWhiteboardContentPropertiesAsync(id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for whiteboard
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response42> GetWhiteboardContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/properties"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response42>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for whiteboard
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateWhiteboardPropertyAsync(long id, ContentPropertyCreateRequest body)
        {
            return CreateWhiteboardPropertyAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for whiteboard
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateWhiteboardPropertyAsync(long id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/properties"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetWhiteboardContentPropertiesByIdAsync(long whiteboard_id, long property_id)
        {
            return GetWhiteboardContentPropertiesByIdAsync(whiteboard_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetWhiteboardContentPropertiesByIdAsync(long whiteboard_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (whiteboard_id == null)
                throw new System.ArgumentNullException("whiteboard_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{whiteboard-id}/properties/{property-id}"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(whiteboard_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard, the whiteboard was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a whiteboard by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateWhiteboardPropertyByIdAsync(long whiteboard_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateWhiteboardPropertyByIdAsync(whiteboard_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a whiteboard by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateWhiteboardPropertyByIdAsync(long whiteboard_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (whiteboard_id == null)
                throw new System.ArgumentNullException("whiteboard_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{whiteboard-id}/properties/{property-id}"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(whiteboard_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a whiteboard by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteWhiteboardPropertyByIdAsync(long whiteboard_id, long property_id)
        {
            return DeleteWhiteboardPropertyByIdAsync(whiteboard_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for whiteboard by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a whiteboard by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the whiteboard.
        /// </remarks>
        /// <param name="whiteboard_id">The ID of the whiteboard the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteWhiteboardPropertyByIdAsync(long whiteboard_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (whiteboard_id == null)
                throw new System.ArgumentNullException("whiteboard_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{whiteboard-id}/properties/{property-id}"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(whiteboard_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetWhiteboardOperationsAsync(long id)
        {
            return GetWhiteboardOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the whiteboard and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetWhiteboardOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/operations"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get direct children of a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns all children for given whiteboard id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent whiteboard.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response43> GetWhiteboardDirectChildrenAsync(long id, string cursor, int? limit, string sort)
        {
            return GetWhiteboardDirectChildrenAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get direct children of a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns all children for given whiteboard id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent whiteboard.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response43> GetWhiteboardDirectChildrenAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/direct-children"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/direct-children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response43>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get descendants of a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given whiteboard by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the whiteboard and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the whiteboard.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response44> GetWhiteboardDescendantsAsync(long id, int? limit, int? depth, string cursor)
        {
            return GetWhiteboardDescendantsAsync(id, limit, depth, cursor, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get descendants of a whiteboard
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given whiteboard by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the whiteboard and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the whiteboard.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response44> GetWhiteboardDescendantsAsync(long id, int? limit, int? depth, string cursor, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/descendants"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/descendants");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response44>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.\ncontent: { }", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all ancestors of whiteboard
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given whiteboard by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the whiteboard and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the whiteboard.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response45> GetWhiteboardAncestorsAsync(long id, int? limit)
        {
            return GetWhiteboardAncestorsAsync(id, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all ancestors of whiteboard
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given whiteboard by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the whiteboard and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the whiteboard.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response45> GetWhiteboardAncestorsAsync(long id, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/ancestors"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/ancestors");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response45>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified whiteboard or the whiteboard was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create database
        /// </summary>
        /// <remarks>
        /// Creates a database in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a database in the space.
        /// </remarks>
        /// <param name="private">The database will be private. Only the user who creates this database will have permission to view and edit one.</param>
        /// <returns>Returned if the database was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response46> CreateDatabaseAsync(bool? @private, object body)
        {
            return CreateDatabaseAsync(@private, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create database
        /// </summary>
        /// <remarks>
        /// Creates a database in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a database in the space.
        /// </remarks>
        /// <param name="private">The database will be private. Only the user who creates this database will have permission to view and edit one.</param>
        /// <returns>Returned if the database was successfully created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response46> CreateDatabaseAsync(bool? @private, object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases"
                    urlBuilder_.Append("databases");
                    urlBuilder_.Append('?');
                    if (@private != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("private")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(@private, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response46>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a database in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get database by id
        /// </summary>
        /// <remarks>
        /// Returns a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the database to be returned</param>
        /// <param name="include_collaborators">Includes collaborators on the database.</param>
        /// <param name="include_direct_children">Includes direct children of the database, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this database in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this database in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested database is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response47> GetDatabaseByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties)
        {
            return GetDatabaseByIdAsync(id, include_collaborators, include_direct_children, include_operations, include_properties, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get database by id
        /// </summary>
        /// <remarks>
        /// Returns a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the database to be returned</param>
        /// <param name="include_collaborators">Includes collaborators on the database.</param>
        /// <param name="include_direct_children">Includes direct children of the database, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this database in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this database in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested database is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response47> GetDatabaseByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_direct_children != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-direct-children")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_direct_children, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response47>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete database
        /// </summary>
        /// <remarks>
        /// Delete a database by id.
        /// <br/>
        /// <br/>Deleting a database moves the database to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// <br/>Permission to delete databases in the space.
        /// </remarks>
        /// <param name="id">The ID of the database to be deleted.</param>
        /// <returns>Returned if the database was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDatabaseAsync(long id)
        {
            return DeleteDatabaseAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete database
        /// </summary>
        /// <remarks>
        /// Delete a database by id.
        /// <br/>
        /// <br/>Deleting a database moves the database to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// <br/>Permission to delete databases in the space.
        /// </remarks>
        /// <param name="id">The ID of the database to be deleted.</param>
        /// <returns>Returned if the database was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDatabaseAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided database does not exist\n- The user does not have permissions to view the database\n- The user does not have the needed permissions to delete a database in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for database
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response48> GetDatabaseContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetDatabaseContentPropertiesAsync(id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for database
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response48> GetDatabaseContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/properties"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response48>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for database
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the database.
        /// </remarks>
        /// <param name="id">The ID of the database to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateDatabasePropertyAsync(long id, ContentPropertyCreateRequest body)
        {
            return CreateDatabasePropertyAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for database
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the database.
        /// </remarks>
        /// <param name="id">The ID of the database to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateDatabasePropertyAsync(long id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/properties"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for database by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetDatabaseContentPropertiesByIdAsync(long database_id, long property_id)
        {
            return GetDatabaseContentPropertiesByIdAsync(database_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for database by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetDatabaseContentPropertiesByIdAsync(long database_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (database_id == null)
                throw new System.ArgumentNullException("database_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{database-id}/properties/{property-id}"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(database_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database, the database was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for database by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a database by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateDatabasePropertyByIdAsync(long database_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateDatabasePropertyByIdAsync(database_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for database by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a database by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateDatabasePropertyByIdAsync(long database_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (database_id == null)
                throw new System.ArgumentNullException("database_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{database-id}/properties/{property-id}"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(database_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for database by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a database by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteDatabasePropertyByIdAsync(long database_id, long property_id)
        {
            return DeleteDatabasePropertyByIdAsync(database_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for database by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a database by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the database.
        /// </remarks>
        /// <param name="database_id">The ID of the database the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteDatabasePropertyByIdAsync(long database_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (database_id == null)
                throw new System.ArgumentNullException("database_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{database-id}/properties/{property-id}"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(database_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for a database
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the database for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetDatabaseOperationsAsync(long id)
        {
            return GetDatabaseOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for a database
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the database and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the database for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetDatabaseOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/operations"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get direct children of a database
        /// </summary>
        /// <remarks>
        /// Returns all children for given database id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent database.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response49> GetDatabaseDirectChildrenAsync(long id, string cursor, int? limit, string sort)
        {
            return GetDatabaseDirectChildrenAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get direct children of a database
        /// </summary>
        /// <remarks>
        /// Returns all children for given database id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent database.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response49> GetDatabaseDirectChildrenAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/direct-children"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/direct-children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response49>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get descendants of a database
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given database by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the database and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the database.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response50> GetDatabaseDescendantsAsync(long id, int? limit, int? depth, string cursor)
        {
            return GetDatabaseDescendantsAsync(id, limit, depth, cursor, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get descendants of a database
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given database by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the database and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the database.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response50> GetDatabaseDescendantsAsync(long id, int? limit, int? depth, string cursor, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/descendants"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/descendants");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response50>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all ancestors of database
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given database by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the database and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the database.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response51> GetDatabaseAncestorsAsync(long id, int? limit)
        {
            return GetDatabaseAncestorsAsync(id, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all ancestors of database
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given database by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the database and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the database.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response51> GetDatabaseAncestorsAsync(long id, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/ancestors"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/ancestors");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response51>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified database or the database was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Creates a Smart Link in the content tree in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a Smart Link in the content tree in the space.
        /// </remarks>
        /// <returns>Returned if the Smart Link was successfully created in the content tree.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response52> CreateSmartLinkAsync(object body)
        {
            return CreateSmartLinkAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Creates a Smart Link in the content tree in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a Smart Link in the content tree in the space.
        /// </remarks>
        /// <returns>Returned if the Smart Link was successfully created in the content tree.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response52> CreateSmartLinkAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds"
                    urlBuilder_.Append("embeds");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response52>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a Smart Link in the content tree in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Returns a specific Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to be returned.</param>
        /// <param name="include_collaborators">Includes collaborators on the Smart Link.</param>
        /// <param name="include_direct_children">Includes direct children of the Smart Link, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this Smart Link in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this Smart Link in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested Smart Link in the content tree is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response53> GetSmartLinkByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties)
        {
            return GetSmartLinkByIdAsync(id, include_collaborators, include_direct_children, include_operations, include_properties, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Returns a specific Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to be returned.</param>
        /// <param name="include_collaborators">Includes collaborators on the Smart Link.</param>
        /// <param name="include_direct_children">Includes direct children of the Smart Link, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this Smart Link in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this Smart Link in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested Smart Link in the content tree is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response53> GetSmartLinkByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_direct_children != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-direct-children")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_direct_children, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response53>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Delete a Smart Link in the content tree by id.
        /// <br/>
        /// <br/>Deleting a Smart Link in the content tree moves the Smart Link to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// <br/>Permission to delete Smart Links in the content tree in the space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to be deleted.</param>
        /// <returns>Returned if the Smart Link in the content tree was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSmartLinkAsync(long id)
        {
            return DeleteSmartLinkAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Delete a Smart Link in the content tree by id.
        /// <br/>
        /// <br/>Deleting a Smart Link in the content tree moves the Smart Link to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// <br/>Permission to delete Smart Links in the content tree in the space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to be deleted.</param>
        /// <returns>Returned if the Smart Link in the content tree was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSmartLinkAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided Smart Link in the content tree does not exist\n- The user does not have permissions to view the Smart Link in the content tree\n- The user does not have the needed permissions to delete a Smart Link in the content tree in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of Smart Links per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response54> GetSmartLinkContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetSmartLinkContentPropertiesAsync(id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of Smart Links per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response54> GetSmartLinkContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/properties"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response54>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the Smart Link in the content tree.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateSmartLinkPropertyAsync(long id, ContentPropertyCreateRequest body)
        {
            return CreateSmartLinkPropertyAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the Smart Link in the content tree.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateSmartLinkPropertyAsync(long id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/properties"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetSmartLinkContentPropertiesByIdAsync(long embed_id, long property_id)
        {
            return GetSmartLinkContentPropertiesByIdAsync(embed_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetSmartLinkContentPropertiesByIdAsync(long embed_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (embed_id == null)
                throw new System.ArgumentNullException("embed_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{embed-id}/properties/{property-id}"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(embed_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree, the Smart Link was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a Smart Link in the content tree by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateSmartLinkPropertyByIdAsync(long embed_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateSmartLinkPropertyByIdAsync(embed_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a Smart Link in the content tree by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateSmartLinkPropertyByIdAsync(long embed_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (embed_id == null)
                throw new System.ArgumentNullException("embed_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{embed-id}/properties/{property-id}"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(embed_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a Smart Link in the content tree by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSmartLinkPropertyByIdAsync(long embed_id, long property_id)
        {
            return DeleteSmartLinkPropertyByIdAsync(embed_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for Smart Link in the content tree by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a Smart Link in the content tree by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the Smart Link in the content tree.
        /// </remarks>
        /// <param name="embed_id">The ID of the Smart Link in the content tree the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSmartLinkPropertyByIdAsync(long embed_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (embed_id == null)
                throw new System.ArgumentNullException("embed_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{embed-id}/properties/{property-id}"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(embed_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for a Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetSmartLinkOperationsAsync(long id)
        {
            return GetSmartLinkOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for a Smart Link in the content tree
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific Smart Link in the content tree.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetSmartLinkOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/operations"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get direct children of a Smart Link
        /// </summary>
        /// <remarks>
        /// Returns all children for given smart link id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent smart link.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response55> GetSmartLinkDirectChildrenAsync(long id, string cursor, int? limit, string sort)
        {
            return GetSmartLinkDirectChildrenAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get direct children of a Smart Link
        /// </summary>
        /// <remarks>
        /// Returns all children for given smart link id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent smart link.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response55> GetSmartLinkDirectChildrenAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/direct-children"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/direct-children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response55>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified smart link or the smart link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get descendants of a smart link
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given smart link by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the smart link and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the smart link.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response56> GetSmartLinkDescendantsAsync(long id, int? limit, int? depth, string cursor)
        {
            return GetSmartLinkDescendantsAsync(id, limit, depth, cursor, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get descendants of a smart link
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given smart link by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the smart link and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the smart link.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response56> GetSmartLinkDescendantsAsync(long id, int? limit, int? depth, string cursor, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/descendants"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/descendants");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response56>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified smart link or the smart link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all ancestors of Smart Link in content tree
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given Smart Link in the content tree by ID in top-to-bottom order (that is, the highest ancestor is
        /// <br/>the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
        /// <br/>(if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get Smart Link in the content tree by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response57> GetSmartLinkAncestorsAsync(long id, int? limit)
        {
            return GetSmartLinkAncestorsAsync(id, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all ancestors of Smart Link in content tree
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given Smart Link in the content tree by ID in top-to-bottom order (that is, the highest ancestor is
        /// <br/>the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
        /// <br/>(if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get Smart Link in the content tree by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the Smart Link in the content tree and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the Smart Link in the content tree.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response57> GetSmartLinkAncestorsAsync(long id, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "embeds/{id}/ancestors"
                    urlBuilder_.Append("embeds/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/ancestors");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response57>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified Smart Link in the content tree or the Smart Link was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create folder
        /// </summary>
        /// <remarks>
        /// Creates a folder in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a folder in the space.
        /// </remarks>
        /// <returns>Returned if the folder was successfully created in the content tree.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response58> CreateFolderAsync(object body)
        {
            return CreateFolderAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create folder
        /// </summary>
        /// <remarks>
        /// Creates a folder in the space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space. Permission to create a folder in the space.
        /// </remarks>
        /// <returns>Returned if the folder was successfully created in the content tree.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response58> CreateFolderAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders"
                    urlBuilder_.Append("folders");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response58>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The space does not exist\n- The user does not have permissions to view the space\n- The user does not have the needed permissions to create a folder in the provided space", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get folder by id
        /// </summary>
        /// <remarks>
        /// Returns a specific folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the folder to be returned.</param>
        /// <param name="include_collaborators">Includes collaborators on the folder.</param>
        /// <param name="include_direct_children">Includes direct children of the folder, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this folder in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this folder in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested folder is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response59> GetFolderByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties)
        {
            return GetFolderByIdAsync(id, include_collaborators, include_direct_children, include_operations, include_properties, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get folder by id
        /// </summary>
        /// <remarks>
        /// Returns a specific folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the folder to be returned.</param>
        /// <param name="include_collaborators">Includes collaborators on the folder.</param>
        /// <param name="include_direct_children">Includes direct children of the folder, as defined in the `ChildrenResponse` object.</param>
        /// <param name="include_operations">Includes operations associated with this folder in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes content properties associated with this folder in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested folder is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response59> GetFolderByIdAsync(long id, bool? include_collaborators, bool? include_direct_children, bool? include_operations, bool? include_properties, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (include_collaborators != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-collaborators")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_collaborators, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_direct_children != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-direct-children")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_direct_children, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response59>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete folder
        /// </summary>
        /// <remarks>
        /// Delete a folder by id.
        /// <br/>
        /// <br/>Deleting a folder moves the folder to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// <br/>Permission to delete folders in the space.
        /// </remarks>
        /// <param name="id">The ID of the folder to be deleted.</param>
        /// <returns>Returned if the folder was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteFolderAsync(long id)
        {
            return DeleteFolderAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete folder
        /// </summary>
        /// <remarks>
        /// Delete a folder by id.
        /// <br/>
        /// <br/>Deleting a folder moves the folder to the trash, where it can be restored later
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// <br/>Permission to delete folders in the space.
        /// </remarks>
        /// <param name="id">The ID of the folder to be deleted.</param>
        /// <returns>Returned if the folder was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteFolderAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided folder does not exist\n- The user does not have permissions to view the folder\n- The user does not have the needed permissions to delete folder in the space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for folder
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder.
        /// </remarks>
        /// <param name="id">The ID of the folder for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response60> GetFolderContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetFolderContentPropertiesAsync(id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for folder
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties tied to a specified folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder.
        /// </remarks>
        /// <param name="id">The ID of the folder for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response60> GetFolderContentPropertiesAsync(long id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/properties"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response60>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for folder
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the folder.
        /// </remarks>
        /// <param name="id">The ID of the folder to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateFolderPropertyAsync(long id, ContentPropertyCreateRequest body)
        {
            return CreateFolderPropertyAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for folder
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the folder.
        /// </remarks>
        /// <param name="id">The ID of the folder to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateFolderPropertyAsync(long id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/properties"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for folder by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetFolderContentPropertiesByIdAsync(long folder_id, long property_id)
        {
            return GetFolderContentPropertiesByIdAsync(folder_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for folder by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetFolderContentPropertiesByIdAsync(long folder_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (folder_id == null)
                throw new System.ArgumentNullException("folder_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{folder-id}/properties/{property-id}"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(folder_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder, the folder was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for folder by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a folder by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateFolderPropertyByIdAsync(long folder_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateFolderPropertyByIdAsync(folder_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for folder by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a folder by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateFolderPropertyByIdAsync(long folder_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (folder_id == null)
                throw new System.ArgumentNullException("folder_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{folder-id}/properties/{property-id}"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(folder_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for folder by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a folder by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteFolderPropertyByIdAsync(long folder_id, long property_id)
        {
            return DeleteFolderPropertyByIdAsync(folder_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for folder by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a folder by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the folder.
        /// </remarks>
        /// <param name="folder_id">The ID of the folder the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteFolderPropertyByIdAsync(long folder_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (folder_id == null)
                throw new System.ArgumentNullException("folder_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{folder-id}/properties/{property-id}"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(folder_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for a folder
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the folder for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetFolderOperationsAsync(long id)
        {
            return GetFolderOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for a folder
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific folder.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the folder and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the folder for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetFolderOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/operations"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get direct children of a folder
        /// </summary>
        /// <remarks>
        /// Returns all children for given folder id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent folder.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response61> GetFolderDirectChildrenAsync(long id, string cursor, int? limit, string sort)
        {
            return GetFolderDirectChildrenAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get direct children of a folder
        /// </summary>
        /// <remarks>
        /// Returns all children for given folder id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent folder.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response61> GetFolderDirectChildrenAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/direct-children"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/direct-children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response61>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get descendants of folder
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given folder by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the  and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the folder.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response62> GetFolderDescendantsAsync(long id, int? limit, int? depth, string cursor)
        {
            return GetFolderDescendantsAsync(id, limit, depth, cursor, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get descendants of folder
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given folder by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the  and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the folder.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response62> GetFolderDescendantsAsync(long id, int? limit, int? depth, string cursor, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/descendants"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/descendants");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response62>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all ancestors of folder
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given folder by ID in top-to-bottom order (that is, the highest ancestor is
        /// <br/>the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
        /// <br/>(if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-folders-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the folder and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the folder.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response63> GetFolderAncestorsAsync(long id, int? limit)
        {
            return GetFolderAncestorsAsync(id, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all ancestors of folder
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given folder by ID in top-to-bottom order (that is, the highest ancestor is
        /// <br/>the first item in the response payload). The number of results is limited by the `limit` parameter and additional results 
        /// <br/>(if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-folders-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the folder and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the folder.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response63> GetFolderAncestorsAsync(long id, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "folders/{id}/ancestors"
                    urlBuilder_.Append("folders/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/ancestors");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response63>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified folder or the folder was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for page version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified page and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which version details should be returned.</param>
        /// <param name="version_number">The version number of the page to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetPageVersionDetailsAsync(long page_id, long version_number)
        {
            return GetPageVersionDetailsAsync(page_id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for page version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified page and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="page_id">The ID of the page for which version details should be returned.</param>
        /// <param name="version_number">The version number of the page to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetPageVersionDetailsAsync(long page_id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (page_id == null)
                throw new System.ArgumentNullException("page_id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{page-id}/versions/{version-number}"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(page_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page, the page was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding page and space.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content to be queried for its versions. If you don't know the custom content ID, use Get custom-content by type and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested custom content versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response64> GetCustomContentVersionsAsync(long custom_content_id, CustomContentBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetCustomContentVersionsAsync(custom_content_id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content versions
        /// </summary>
        /// <remarks>
        /// Returns the versions of specific custom content.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and its corresponding page and space.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content to be queried for its versions. If you don't know the custom content ID, use Get custom-content by type and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested custom content versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response64> GetCustomContentVersionsAsync(long custom_content_id, CustomContentBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/versions"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response64>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested custom content or the custom content was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for custom content version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified custom content and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which version details should be returned.</param>
        /// <param name="version_number">The version number of the custom content to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetCustomContentVersionDetailsAsync(long custom_content_id, long version_number)
        {
            return GetCustomContentVersionDetailsAsync(custom_content_id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for custom content version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified custom content and version number.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the page.
        /// </remarks>
        /// <param name="custom_content_id">The ID of the custom content for which version details should be returned.</param>
        /// <param name="version_number">The version number of the custom content to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetCustomContentVersionDetailsAsync(long custom_content_id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (custom_content_id == null)
                throw new System.ArgumentNullException("custom_content_id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{custom-content-id}/versions/{version-number}"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(custom_content_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified custom content, the custom content was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get spaces
        /// </summary>
        /// <remarks>
        /// Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
        /// <br/>additional results (if available) will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only spaces that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="ids">Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="keys">Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.</param>
        /// <param name="type">Filter the results to spaces based on their type.</param>
        /// <param name="status">Filter the results to spaces based on their status.</param>
        /// <param name="labels">Filter the results to spaces based on their labels. Multiple labels can be specified as a comma-separated list.</param>
        /// <param name="favorited_by">Filter the results to spaces favorited by the user with the specified account ID.</param>
        /// <param name="not_favorited_by">Filter the results to spaces NOT favorited by the user with the specified account ID.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="description_format">The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.</param>
        /// <param name="include_icon">If the icon for the space should be fetched or not.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested spaces are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response65> GetSpacesAsync(System.Collections.Generic.IEnumerable<long> ids, System.Collections.Generic.IEnumerable<string> keys, ConfluenceType? type, Status? status, System.Collections.Generic.IEnumerable<string> labels, string favorited_by, string not_favorited_by, SpaceSortOrder? sort, SpaceDescriptionBodyRepresentation? description_format, bool? include_icon, string cursor, int? limit)
        {
            return GetSpacesAsync(ids, keys, type, status, labels, favorited_by, not_favorited_by, sort, description_format, include_icon, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get spaces
        /// </summary>
        /// <remarks>
        /// Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
        /// <br/>additional results (if available) will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only spaces that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="ids">Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="keys">Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.</param>
        /// <param name="type">Filter the results to spaces based on their type.</param>
        /// <param name="status">Filter the results to spaces based on their status.</param>
        /// <param name="labels">Filter the results to spaces based on their labels. Multiple labels can be specified as a comma-separated list.</param>
        /// <param name="favorited_by">Filter the results to spaces favorited by the user with the specified account ID.</param>
        /// <param name="not_favorited_by">Filter the results to spaces NOT favorited by the user with the specified account ID.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="description_format">The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.</param>
        /// <param name="include_icon">If the icon for the space should be fetched or not.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested spaces are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response65> GetSpacesAsync(System.Collections.Generic.IEnumerable<long> ids, System.Collections.Generic.IEnumerable<string> keys, ConfluenceType? type, Status? status, System.Collections.Generic.IEnumerable<string> labels, string favorited_by, string not_favorited_by, SpaceSortOrder? sort, SpaceDescriptionBodyRepresentation? description_format, bool? include_icon, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces"
                    urlBuilder_.Append("spaces");
                    urlBuilder_.Append('?');
                    if (ids != null)
                    {
                        foreach (var item_ in ids) { urlBuilder_.Append(System.Uri.EscapeDataString("ids")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (keys != null)
                    {
                        foreach (var item_ in keys) { urlBuilder_.Append(System.Uri.EscapeDataString("keys")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (labels != null)
                    {
                        foreach (var item_ in labels) { urlBuilder_.Append(System.Uri.EscapeDataString("labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (favorited_by != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("favorited-by")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(favorited_by, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (not_favorited_by != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("not-favorited-by")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(not_favorited_by, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (description_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("description-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(description_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_icon != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-icon")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_icon, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response65>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create space
        /// </summary>
        /// <remarks>
        /// Creates a Space as specified in the payload.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to create spaces.
        /// </remarks>
        /// <returns>Returned if the requested space is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response66> CreateSpaceAsync(object body)
        {
            return CreateSpaceAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create space
        /// </summary>
        /// <remarks>
        /// Creates a Space as specified in the payload.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to create spaces.
        /// </remarks>
        /// <returns>Returned if the requested space is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response66> CreateSpaceAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces"
                    urlBuilder_.Append("spaces");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response66>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to create spaces.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space by id
        /// </summary>
        /// <remarks>
        /// Returns a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space to be returned.</param>
        /// <param name="description_format">The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.</param>
        /// <param name="include_icon">If the icon for the space should be fetched or not.</param>
        /// <param name="include_operations">Includes operations associated with this space in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes space properties associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_permissions">Includes space permissions associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_role_assignments">Includes role assignments associated with this space in the response. This parameter is only accepted for EAP sites.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_labels">Includes labels associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested space is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response67> GetSpaceByIdAsync(long id, SpaceDescriptionBodyRepresentation? description_format, bool? include_icon, bool? include_operations, bool? include_properties, bool? include_permissions, bool? include_role_assignments, bool? include_labels)
        {
            return GetSpaceByIdAsync(id, description_format, include_icon, include_operations, include_properties, include_permissions, include_role_assignments, include_labels, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space by id
        /// </summary>
        /// <remarks>
        /// Returns a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space to be returned.</param>
        /// <param name="description_format">The content format type to be returned in the `description` field of the response. If available, the representation will be available under a response field of the same name under the `description` field.</param>
        /// <param name="include_icon">If the icon for the space should be fetched or not.</param>
        /// <param name="include_operations">Includes operations associated with this space in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_properties">Includes space properties associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_permissions">Includes space permissions associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_role_assignments">Includes role assignments associated with this space in the response. This parameter is only accepted for EAP sites.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_labels">Includes labels associated with this space in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order.
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <returns>Returned if the requested space is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response67> GetSpaceByIdAsync(long id, SpaceDescriptionBodyRepresentation? description_format, bool? include_icon, bool? include_operations, bool? include_properties, bool? include_permissions, bool? include_role_assignments, bool? include_labels, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (description_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("description-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(description_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_icon != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-icon")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_icon, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_permissions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-permissions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_permissions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_role_assignments != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-role-assignments")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_role_assignments, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_labels != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-labels")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_labels, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response67>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog posts in space
        /// </summary>
        /// <remarks>
        /// Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and view the space.
        /// <br/>Only blog posts that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which blog posts should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to blog posts based on their status. By default, `current` is used.</param>
        /// <param name="title">Filter the results to blog posts based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response68> GetBlogPostsInSpaceAsync(long id, BlogPostSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous9> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit)
        {
            return GetBlogPostsInSpaceAsync(id, sort, status, title, body_format, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog posts in space
        /// </summary>
        /// <remarks>
        /// Returns all blog posts in a space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and view the space.
        /// <br/>Only blog posts that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which blog posts should be returned.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to blog posts based on their status. By default, `current` is used.</param>
        /// <param name="title">Filter the results to blog posts based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of blog posts per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested blog posts are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response68> GetBlogPostsInSpaceAsync(long id, BlogPostSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous9> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/blogposts"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/blogposts");
                    urlBuilder_.Append('?');
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response68>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for space
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response69> GetSpaceLabelsAsync(long id, Prefix5? prefix, string sort, string cursor, int? limit)
        {
            return GetSpaceLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for space
        /// </summary>
        /// <remarks>
        /// Returns the labels of specific space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response69> GetSpaceLabelsAsync(long id, Prefix5? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/labels"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response69>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get labels for space content
        /// </summary>
        /// <remarks>
        /// Returns the labels of space content (pages, blogposts etc). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response70> GetSpaceContentLabelsAsync(long id, Prefix6? prefix, string sort, string cursor, int? limit)
        {
            return GetSpaceContentLabelsAsync(id, prefix, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get labels for space content
        /// </summary>
        /// <remarks>
        /// Returns the labels of space content (pages, blogposts etc). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// <br/>Only labels that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which labels should be returned.</param>
        /// <param name="prefix">Filter the results to labels based on their prefix.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of labels per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested labels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response70> GetSpaceContentLabelsAsync(long id, Prefix6? prefix, string sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/content/labels"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/content/labels");
                    urlBuilder_.Append('?');
                    if (prefix != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("prefix")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(prefix, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response70>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get custom content by type in space
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the space for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response71> GetCustomContentByTypeInSpaceAsync(long id, string type, string cursor, int? limit, CustomContentBodyRepresentation? body_format)
        {
            return GetCustomContentByTypeInSpaceAsync(id, type, cursor, limit, body_format, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get custom content by type in space
        /// </summary>
        /// <remarks>
        /// Returns all custom content for a given type within a given space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the custom content and the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the space for which custom content should be returned.</param>
        /// <param name="type">The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.
        /// <br/>
        /// <br/>Note: If the custom content body type is `storage`, the `storage` and `atlas_doc_format` body formats are able to be returned. If the custom content body type is `raw`, only the `raw` body format is able to be returned.</param>
        /// <returns>Returned if the requested custom content is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response71> GetCustomContentByTypeInSpaceAsync(long id, string type, string cursor, int? limit, CustomContentBodyRepresentation? body_format, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (type == null)
                throw new System.ArgumentNullException("type");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/custom-content"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/custom-content");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response71>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the space is not found. Returned if the type of custom content is not found. Note, this is distinct from the type being present, but no instances of the type, which would be a 200 with empty results.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for space
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the space for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetSpaceOperationsAsync(long id)
        {
            return GetSpaceOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for space
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the space for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetSpaceOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/operations"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspace or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get pages in space
        /// </summary>
        /// <remarks>
        /// Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which pages should be returned.</param>
        /// <param name="depth">Filter the results to pages at the root level of the space or to all pages in the space.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to pages based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="title">Filter the results to pages based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response72> GetPagesInSpaceAsync(long id, Depth? depth, PageSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous10> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit)
        {
            return GetPagesInSpaceAsync(id, depth, sort, status, title, body_format, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get pages in space
        /// </summary>
        /// <remarks>
        /// Returns all pages in a space. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the space for which pages should be returned.</param>
        /// <param name="depth">Filter the results to pages at the root level of the space or to all pages in the space.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="status">Filter the results to pages based on their status. By default, `current` and `archived` are used.</param>
        /// <param name="title">Filter the results to pages based on their title.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response72> GetPagesInSpaceAsync(long id, Depth? depth, PageSortOrder? sort, System.Collections.Generic.IEnumerable<Anonymous10> status, string title, PrimaryBodyRepresentation? body_format, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/pages"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/pages");
                    urlBuilder_.Append('?');
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (title != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("title")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(title, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response72>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space properties in space
        /// </summary>
        /// <remarks>
        /// Returns all properties for the given space. Space properties are a key-value storage associated with a space.
        /// <br/>The limit parameter specifies the maximum number of results returned in a single response. Use the `link` response header
        /// <br/>to paginate through additional results.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space for which space properties should be returned.</param>
        /// <param name="key">The key of the space property to retrieve. This should be used when a user knows the key of their property, but needs to retrieve the id for use in other methods.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space properties are returned. `results` may be empty if no results were found.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response73> GetSpacePropertiesAsync(long space_id, string key, string cursor, int? limit)
        {
            return GetSpacePropertiesAsync(space_id, key, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space properties in space
        /// </summary>
        /// <remarks>
        /// Returns all properties for the given space. Space properties are a key-value storage associated with a space.
        /// <br/>The limit parameter specifies the maximum number of results returned in a single response. Use the `link` response header
        /// <br/>to paginate through additional results.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space for which space properties should be returned.</param>
        /// <param name="key">The key of the space property to retrieve. This should be used when a user knows the key of their property, but needs to retrieve the id for use in other methods.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space properties are returned. `results` may be empty if no results were found.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response73> GetSpacePropertiesAsync(long space_id, string key, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (space_id == null)
                throw new System.ArgumentNullException("space_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{space-id}/properties"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response73>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create space property in space
        /// </summary>
        /// <remarks>
        /// Creates a new space property.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space for which space properties should be returned.</param>
        /// <param name="body">The space property to be created</param>
        /// <returns>Returned if the space property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SpaceProperty> CreateSpacePropertyAsync(long space_id, SpacePropertyCreateRequest body)
        {
            return CreateSpacePropertyAsync(space_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create space property in space
        /// </summary>
        /// <remarks>
        /// Creates a new space property.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space for which space properties should be returned.</param>
        /// <param name="body">The space property to be created</param>
        /// <returns>Returned if the space property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SpaceProperty> CreateSpacePropertyAsync(long space_id, SpacePropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (space_id == null)
                throw new System.ArgumentNullException("space_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{space-id}/properties"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpaceProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space property by id
        /// </summary>
        /// <remarks>
        /// Retrieve a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be retrieved.</param>
        /// <returns>Returned if the space property was retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SpaceProperty> GetSpacePropertyByIdAsync(long space_id, long property_id)
        {
            return GetSpacePropertyByIdAsync(space_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space property by id
        /// </summary>
        /// <remarks>
        /// Retrieve a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'View' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be retrieved.</param>
        /// <returns>Returned if the space property was retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SpaceProperty> GetSpacePropertyByIdAsync(long space_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (space_id == null)
                throw new System.ArgumentNullException("space_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{space-id}/properties/{property-id}"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpaceProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update space property by id
        /// </summary>
        /// <remarks>
        /// Update a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The space property to be updated.</param>
        /// <returns>Returned if the space property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SpaceProperty> UpdateSpacePropertyByIdAsync(long space_id, long property_id, SpacePropertyUpdateRequest body)
        {
            return UpdateSpacePropertyByIdAsync(space_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update space property by id
        /// </summary>
        /// <remarks>
        /// Update a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The space property to be updated.</param>
        /// <returns>Returned if the space property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SpaceProperty> UpdateSpacePropertyByIdAsync(long space_id, long property_id, SpacePropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (space_id == null)
                throw new System.ArgumentNullException("space_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{space-id}/properties/{property-id}"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SpaceProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete space property by id
        /// </summary>
        /// <remarks>
        /// Deletes a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the space property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSpacePropertyByIdAsync(long space_id, long property_id)
        {
            return DeleteSpacePropertyByIdAsync(space_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete space property by id
        /// </summary>
        /// <remarks>
        /// Deletes a space property by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="space_id">The ID of the space the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the space property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSpacePropertyByIdAsync(long space_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (space_id == null)
                throw new System.ArgumentNullException("space_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{space-id}/properties/{property-id}"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified space or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space permissions assignments
        /// </summary>
        /// <remarks>
        /// Returns space permission assignments for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space to be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of assignments to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested assignments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response74> GetSpacePermissionsAssignmentsAsync(long id, string cursor, int? limit)
        {
            return GetSpacePermissionsAssignmentsAsync(id, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space permissions assignments
        /// </summary>
        /// <remarks>
        /// Returns space permission assignments for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space to be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of assignments to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested assignments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response74> GetSpacePermissionsAssignmentsAsync(long id, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/permissions"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/permissions");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response74>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested space permission assignments or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get available space permissions
        /// </summary>
        /// <remarks>
        /// Retrieves the available space permissions.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site.
        /// </remarks>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space permissions to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space permissions are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response75> GetAvailableSpacePermissionsAsync(string cursor, int? limit)
        {
            return GetAvailableSpacePermissionsAsync(cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get available space permissions
        /// </summary>
        /// <remarks>
        /// Retrieves the available space permissions.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site.
        /// </remarks>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space permissions to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space permissions are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response75> GetAvailableSpacePermissionsAsync(string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "space-permissions"
                    urlBuilder_.Append("space-permissions");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response75>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\navailable space permissions.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get available space roles
        /// </summary>
        /// <remarks>
        /// Retrieves the available space roles.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site; if requesting a certain space's roles, permission to view the space.
        /// </remarks>
        /// <param name="space_id">The space ID for which to filter available space roles; if empty, return all available space roles for the tenant.</param>
        /// <param name="role_type">The space role type to filter results by.</param>
        /// <param name="principal_id">The principal ID to filter results by. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`]</param>
        /// <param name="principal_type">The principal type to filter results by. If specified, a principal-id must also be specified.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space roles are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response76> GetAvailableSpaceRolesAsync(string space_id, string role_type, string principal_id, PrincipalType? principal_type, string cursor, int? limit)
        {
            return GetAvailableSpaceRolesAsync(space_id, role_type, principal_id, principal_type, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get available space roles
        /// </summary>
        /// <remarks>
        /// Retrieves the available space roles.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site; if requesting a certain space's roles, permission to view the space.
        /// </remarks>
        /// <param name="space_id">The space ID for which to filter available space roles; if empty, return all available space roles for the tenant.</param>
        /// <param name="role_type">The space role type to filter results by.</param>
        /// <param name="principal_id">The principal ID to filter results by. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`]</param>
        /// <param name="principal_type">The principal type to filter results by. If specified, a principal-id must also be specified.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space roles are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response76> GetAvailableSpaceRolesAsync(string space_id, string role_type, string principal_id, PrincipalType? principal_type, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "space-roles"
                    urlBuilder_.Append("space-roles");
                    urlBuilder_.Append('?');
                    if (space_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(space_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (role_type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("role-type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(role_type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (principal_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("principal-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(principal_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (principal_type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("principal-type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(principal_type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response76>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\navailable space roles.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space role by ID
        /// </summary>
        /// <remarks>
        /// Retrieves the space role by ID.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site.
        /// </remarks>
        /// <param name="id">The ID of the space role to retrieve.</param>
        /// <returns>Returned if the requested space role is retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response77> GetSpaceRolesByIdAsync(int id)
        {
            return GetSpaceRolesByIdAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space role by ID
        /// </summary>
        /// <remarks>
        /// Retrieves the space role by ID.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site.
        /// </remarks>
        /// <param name="id">The ID of the space role to retrieve.</param>
        /// <returns>Returned if the requested space role is retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response77> GetSpaceRolesByIdAsync(int id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "space-roles/{id}"
                    urlBuilder_.Append("space-roles/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response77>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspace role.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space role assignments
        /// </summary>
        /// <remarks>
        /// Retrieves the space role assignments.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which to retrieve assignments.</param>
        /// <param name="role_id">Filters the returned role assignments to the provided role ID.</param>
        /// <param name="role_type">Filters the returned role assignments to the provided role type.</param>
        /// <param name="principal_id">Filters the returned role assignments to the provided principal id. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`]</param>
        /// <param name="principal_type">Filters the returned role assignments to the provided principal type. If specified, a principal-id must also be specified.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space role assignments are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response78> GetSpaceRoleAssignmentsAsync(int id, string role_id, string role_type, string principal_id, PrincipalType? principal_type, string cursor, int? limit)
        {
            return GetSpaceRoleAssignmentsAsync(id, role_id, role_type, principal_id, principal_type, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space role assignments
        /// </summary>
        /// <remarks>
        /// Retrieves the space role assignments.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which to retrieve assignments.</param>
        /// <param name="role_id">Filters the returned role assignments to the provided role ID.</param>
        /// <param name="role_type">Filters the returned role assignments to the provided role type.</param>
        /// <param name="principal_id">Filters the returned role assignments to the provided principal id. If specified, a principal-type must also be specified. Paired with a `principal-type` of `ACCESS_CLASS`, valid values include [`anonymous-users`, `jsm-project-admins`, `authenticated-users`, `all-licensed-users`, `all-product-admins`]</param>
        /// <param name="principal_type">Filters the returned role assignments to the provided principal type. If specified, a principal-id must also be specified.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of space roles to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested space role assignments are retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response78> GetSpaceRoleAssignmentsAsync(int id, string role_id, string role_type, string principal_id, PrincipalType? principal_type, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/role-assignments"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/role-assignments");
                    urlBuilder_.Append('?');
                    if (role_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("role-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(role_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (role_type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("role-type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(role_type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (principal_id != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("principal-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(principal_id, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (principal_type != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("principal-type")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(principal_type, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response78>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspace or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Set space role assignments
        /// </summary>
        /// <remarks>
        /// Sets space role assignments as specified in the payload.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to manage roles in the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which to retrieve assignments.</param>
        /// <returns>Returned if the requested update to space role assignments succeeds in its entirety.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response79> SetSpaceRoleAssignmentsAsync(int id, object body)
        {
            return SetSpaceRoleAssignmentsAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Set space role assignments
        /// </summary>
        /// <remarks>
        /// Sets space role assignments as specified in the payload.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to manage roles in the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which to retrieve assignments.</param>
        /// <returns>Returned if the requested update to space role assignments succeeds in its entirety.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response79> SetSpaceRoleAssignmentsAsync(int id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/role-assignments"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/role-assignments");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response79>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to set roles in the space, or the space was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 413)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is too large in size (over 5 MB).", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get footer comments for page
        /// </summary>
        /// <remarks>
        /// Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which footer comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the footer comment being retrieved by its status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response80> GetPageFooterCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous11> status, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetPageFooterCommentsAsync(id, body_format, status, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get footer comments for page
        /// </summary>
        /// <remarks>
        /// Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which footer comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the footer comment being retrieved by its status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response80> GetPageFooterCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous11> status, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/footer-comments"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/footer-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response80>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inline comments for page
        /// </summary>
        /// <remarks>
        /// Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which inline comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the inline comment being retrieved by its status.</param>
        /// <param name="resolution_status">Filter the inline comment being retrieved by its resolution status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response81> GetPageInlineCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous12> status, System.Collections.Generic.IEnumerable<Anonymous13> resolution_status, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetPageInlineCommentsAsync(id, body_format, status, resolution_status, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inline comments for page
        /// </summary>
        /// <remarks>
        /// Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the page for which inline comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the inline comment being retrieved by its status.</param>
        /// <param name="resolution_status">Filter the inline comment being retrieved by its resolution status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response81> GetPageInlineCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous12> status, System.Collections.Generic.IEnumerable<Anonymous13> resolution_status, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/inline-comments"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/inline-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (resolution_status != null)
                    {
                        foreach (var item_ in resolution_status) { urlBuilder_.Append(System.Uri.EscapeDataString("resolution-status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response81>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get footer comments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which footer comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the footer comment being retrieved by its status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response82> GetBlogPostFooterCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous14> status, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetBlogPostFooterCommentsAsync(id, body_format, status, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get footer comments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which footer comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the footer comment being retrieved by its status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response82> GetBlogPostFooterCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous14> status, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/footer-comments"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/footer-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response82>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inline comments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which inline comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the inline comment being retrieved by its status.</param>
        /// <param name="resolution_status">Filter the inline comment being retrieved by its resolution status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response83> GetBlogPostInlineCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous15> status, System.Collections.Generic.IEnumerable<Anonymous16> resolution_status, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetBlogPostInlineCommentsAsync(id, body_format, status, resolution_status, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inline comments for blog post
        /// </summary>
        /// <remarks>
        /// Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which inline comments should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="status">Filter the inline comment being retrieved by its status.</param>
        /// <param name="resolution_status">Filter the inline comment being retrieved by its resolution status.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of inline comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response83> GetBlogPostInlineCommentsAsync(long id, PrimaryBodyRepresentation? body_format, System.Collections.Generic.IEnumerable<Anonymous15> status, System.Collections.Generic.IEnumerable<Anonymous16> resolution_status, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/inline-comments"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/inline-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        foreach (var item_ in status) { urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (resolution_status != null)
                    {
                        foreach (var item_ in resolution_status) { urlBuilder_.Append(System.Uri.EscapeDataString("resolution-status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response83>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested blog post or the blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get footer comments
        /// </summary>
        /// <remarks>
        /// Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the container and its corresponding space.
        /// </remarks>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response84> GetFooterCommentsAsync(PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetFooterCommentsAsync(body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get footer comments
        /// </summary>
        /// <remarks>
        /// Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the container and its corresponding space.
        /// </remarks>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response84> GetFooterCommentsAsync(PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments"
                    urlBuilder_.Append("footer-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response84>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create footer comment
        /// </summary>
        /// <remarks>
        /// Create a footer comment.
        /// <br/>
        /// <br/>The footer comment can be made against several locations: 
        /// <br/>- at the top level (specifying pageId or blogPostId in the request body)
        /// <br/>- as a reply (specifying parentCommentId in the request body)
        /// <br/>- against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments)
        /// <br/>- against a custom content
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="body">The footer comment to be created</param>
        /// <returns>Returned if the footer comment is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response85> CreateFooterCommentAsync(CreateFooterCommentModel body)
        {
            return CreateFooterCommentAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create footer comment
        /// </summary>
        /// <remarks>
        /// Create a footer comment.
        /// <br/>
        /// <br/>The footer comment can be made against several locations: 
        /// <br/>- at the top level (specifying pageId or blogPostId in the request body)
        /// <br/>- as a reply (specifying parentCommentId in the request body)
        /// <br/>- against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments)
        /// <br/>- against a custom content
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="body">The footer comment to be created</param>
        /// <returns>Returned if the footer comment is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response85> CreateFooterCommentAsync(CreateFooterCommentModel body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments"
                    urlBuilder_.Append("footer-comments");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response85>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The page, blog post, parent comment, or attachment was not found\n- The calling user does not have permission to view the parent page/blog post\n- The user is forbidden from creating a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get footer comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a footer comment by id
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the container and its corresponding space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_properties">Includes content properties associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this footer comment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this footer comment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <returns>Returned if the footer comment is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response86> GetFooterCommentByIdAsync(long comment_id, PrimaryBodyRepresentationSingle? body_format, int? version, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version)
        {
            return GetFooterCommentByIdAsync(comment_id, body_format, version, include_properties, include_operations, include_likes, include_versions, include_version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get footer comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a footer comment by id
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the container and its corresponding space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_properties">Includes content properties associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this footer comment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this footer comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this footer comment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <returns>Returned if the footer comment is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response86> GetFooterCommentByIdAsync(long comment_id, PrimaryBodyRepresentationSingle? body_format, int? version, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{comment-id}"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_likes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-likes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_likes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response86>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\ncomment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update footer comment
        /// </summary>
        /// <remarks>
        /// Update a footer comment. This can be used to update the body text of a comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body">The footer comment to be created</param>
        /// <returns>Returned if the footer comment is updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<FooterCommentModel> UpdateFooterCommentAsync(long comment_id, Body body)
        {
            return UpdateFooterCommentAsync(comment_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update footer comment
        /// </summary>
        /// <remarks>
        /// Update a footer comment. This can be used to update the body text of a comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body">The footer comment to be created</param>
        /// <returns>Returned if the footer comment is updated successfully</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<FooterCommentModel> UpdateFooterCommentAsync(long comment_id, Body body, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{comment-id}"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<FooterCommentModel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The comment was not found\n- The calling user does not have permission to view the comment\n- The user is forbidden from updating a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete footer comment
        /// </summary>
        /// <remarks>
        /// Deletes a footer comment. This is a permanent deletion and cannot be reverted.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <returns>Returned if the footer comment is deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteFooterCommentAsync(long comment_id)
        {
            return DeleteFooterCommentAsync(comment_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete footer comment
        /// </summary>
        /// <remarks>
        /// Deletes a footer comment. This is a permanent deletion and cannot be reverted.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <returns>Returned if the footer comment is deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteFooterCommentAsync(long comment_id, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{comment-id}"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The comment was not found\n- The calling user does not have permission to view the comment\n- The user is forbidden from deleting a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get children footer comments
        /// </summary>
        /// <remarks>
        /// Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the parent comment for which footer comment children should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response87> GetFooterCommentChildrenAsync(long id, PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetFooterCommentChildrenAsync(id, body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get children footer comments
        /// </summary>
        /// <remarks>
        /// Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the parent comment for which footer comment children should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response87> GetFooterCommentChildrenAsync(long id, PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/children"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/children");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response87>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent page/blog post or the page/blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get like count for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Anonymous18> GetFooterLikeCountAsync(long id)
        {
            return GetFooterLikeCountAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get like count for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Anonymous18> GetFooterLikeCountAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/likes/count"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/count");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Anonymous18>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get account IDs of likes for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response88> GetFooterLikeUsersAsync(long id, string cursor, int? limit)
        {
            return GetFooterLikeUsersAsync(id, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get account IDs of likes for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response88> GetFooterLikeUsersAsync(long id, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/likes/users"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/users");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response88>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the footer comment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetFooterCommentOperationsAsync(long id)
        {
            return GetFooterCommentOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for footer comment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the footer comment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetFooterCommentOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/operations"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested footer comment or the footer comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get footer comment versions
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of the specified footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which versions should be returned</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested footer comment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response89> GetFooterCommentVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetFooterCommentVersionsAsync(id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get footer comment versions
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of the specified footer comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which versions should be returned</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested footer comment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response89> GetFooterCommentVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/versions"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response89>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the specified page\nor blog post, the footer comment was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for footer comment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified footer comment version.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the footer comment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetFooterCommentVersionDetailsAsync(long id, long version_number)
        {
            return GetFooterCommentVersionDetailsAsync(id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for footer comment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified footer comment version.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the footer comment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the footer comment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetFooterCommentVersionDetailsAsync(long id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "footer-comments/{id}/versions/{version-number}"
                    urlBuilder_.Append("footer-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the specified page\nor blog post, the footer comment was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inline comments
        /// </summary>
        /// <remarks>
        /// Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response90> GetInlineCommentsAsync(PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetInlineCommentsAsync(body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inline comments
        /// </summary>
        /// <remarks>
        /// Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested inline comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response90> GetInlineCommentsAsync(PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments"
                    urlBuilder_.Append("inline-comments");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response90>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create inline comment
        /// </summary>
        /// <remarks>
        /// Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
        /// <br/>or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
        /// <br/>request body is used to select the text the inline comment should be tied to. This is what determines the text 
        /// <br/>highlighting when viewing a page in Confluence.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="body">The inline comment to be created</param>
        /// <returns>Returned if the inline comment is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response91> CreateInlineCommentAsync(CreateInlineCommentModel body)
        {
            return CreateInlineCommentAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create inline comment
        /// </summary>
        /// <remarks>
        /// Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body)
        /// <br/>or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the
        /// <br/>request body is used to select the text the inline comment should be tied to. This is what determines the text 
        /// <br/>highlighting when viewing a page in Confluence.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="body">The inline comment to be created</param>
        /// <returns>Returned if the inline comment is created.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response91> CreateInlineCommentAsync(CreateInlineCommentModel body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments"
                    urlBuilder_.Append("inline-comments");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response91>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The page/blog post was not found\n- The calling user does not have permission to view the parent page/blog post\n- The user is forbidden from creating a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inline comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves an inline comment by id
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_properties">Includes content properties associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this inline comment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this inline comment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <returns>Returned if the inline comment is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response92> GetInlineCommentByIdAsync(long comment_id, PrimaryBodyRepresentationSingle? body_format, int? version, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version)
        {
            return GetInlineCommentByIdAsync(comment_id, body_format, version, include_properties, include_operations, include_likes, include_versions, include_version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inline comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves an inline comment by id
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="version">Allows you to retrieve a previously published version. Specify the previous version's number to retrieve its details.</param>
        /// <param name="include_properties">Includes content properties associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_operations">Includes operations associated with this inline comment in the response, as defined in the `Operation` object.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_likes">Includes likes associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_versions">Includes versions associated with this inline comment in the response.
        /// <br/>The number of results will be limited to 50 and sorted in the default sort order. 
        /// <br/>A `meta` and `_links` property will be present to indicate if more results are available and a link to retrieve the rest of the results.</param>
        /// <param name="include_version">Includes the current version associated with this inline comment in the response.
        /// <br/>By default this is included and can be omitted by setting the value to `false`.</param>
        /// <returns>Returned if the inline comment is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response92> GetInlineCommentByIdAsync(long comment_id, PrimaryBodyRepresentationSingle? body_format, int? version, bool? include_properties, bool? include_operations, bool? include_likes, bool? include_versions, bool? include_version, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{comment-id}"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_properties != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-properties")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_properties, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_operations != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-operations")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_operations, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_likes != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-likes")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_likes, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_versions != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-versions")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_versions, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response92>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\ncomment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update inline comment
        /// </summary>
        /// <remarks>
        /// Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body">The inline comment to be updated</param>
        /// <returns>Returned if the inline comment is updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response93> UpdateInlineCommentAsync(long comment_id, UpdateInlineCommentModel body)
        {
            return UpdateInlineCommentAsync(comment_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update inline comment
        /// </summary>
        /// <remarks>
        /// Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be retrieved.</param>
        /// <param name="body">The inline comment to be updated</param>
        /// <returns>Returned if the inline comment is updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response93> UpdateInlineCommentAsync(long comment_id, UpdateInlineCommentModel body, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{comment-id}"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response93>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The comment was not found\n- The calling user does not have permission to view the comment\n- The user is forbidden from updating a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete inline comment
        /// </summary>
        /// <remarks>
        /// Deletes an inline comment. This is a permanent deletion and cannot be reverted.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be deleted.</param>
        /// <returns>Returned if the inline comment is deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteInlineCommentAsync(long comment_id)
        {
            return DeleteInlineCommentAsync(comment_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete inline comment
        /// </summary>
        /// <remarks>
        /// Deletes an inline comment. This is a permanent deletion and cannot be reverted.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to be deleted.</param>
        /// <returns>Returned if the inline comment is deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteInlineCommentAsync(long comment_id, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{comment-id}"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The comment was not found\n- The calling user does not have permission to view the comment\n- The user is forbidden from deleting a comment tied to a resource they are allowed to view", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get children inline comments
        /// </summary>
        /// <remarks>
        /// Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the parent comment for which inline comment children should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response94> GetInlineCommentChildrenAsync(long id, PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit)
        {
            return GetInlineCommentChildrenAsync(id, body_format, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get children inline comments
        /// </summary>
        /// <remarks>
        /// Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the parent comment for which inline comment children should be returned.</param>
        /// <param name="body_format">The content format type to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of footer comments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested footer comments are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response94> GetInlineCommentChildrenAsync(long id, PrimaryBodyRepresentation? body_format, CommentSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/children"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/children");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response94>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent page/blog post or the page/blog post was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get like count for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Anonymous19> GetInlineLikeCountAsync(long id)
        {
            return GetInlineLikeCountAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get like count for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the count of likes of specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which like count should be returned.</param>
        /// <returns>Returned if the requested count is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Anonymous19> GetInlineLikeCountAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/likes/count"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/count");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Anonymous19>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get account IDs of likes for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response95> GetInlineLikeUsersAsync(long id, string cursor, int? limit)
        {
            return GetInlineLikeUsersAsync(id, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get account IDs of likes for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the account IDs of likes of specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page/blogpost and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which like count should be returned.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of account IDs per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested account IDs are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response95> GetInlineLikeUsersAsync(long id, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/likes/users"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/likes/users");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response95>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get permitted operations for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the inline comment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PermittedOperationsResponse> GetInlineCommentOperationsAsync(long id)
        {
            return GetInlineCommentOperationsAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get permitted operations for inline comment
        /// </summary>
        /// <remarks>
        /// Returns the permitted operations on specific inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the parent content of the inline comment and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which operations should be returned.</param>
        /// <returns>Returned if the requested operations are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PermittedOperationsResponse> GetInlineCommentOperationsAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/operations"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/operations");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PermittedOperationsResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nparent content of the requested inline comment or the inline comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get inline comment versions
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of the specified inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which versions should be returned</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested inline comment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response96> GetInlineCommentVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort)
        {
            return GetInlineCommentVersionsAsync(id, body_format, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get inline comment versions
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of the specified inline comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which versions should be returned</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of versions per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested inline comment versions are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response96> GetInlineCommentVersionsAsync(long id, PrimaryBodyRepresentation? body_format, string cursor, int? limit, VersionSortOrder? sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/versions"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response96>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the specified page\nor blog post, the inline comment was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get version details for inline comment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified inline comment version.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the inline comment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DetailedVersion> GetInlineCommentVersionDetailsAsync(long id, long version_number)
        {
            return GetInlineCommentVersionDetailsAsync(id, version_number, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get version details for inline comment version
        /// </summary>
        /// <remarks>
        /// Retrieves version details for the specified inline comment version.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the content of the page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the inline comment for which version details should be returned.</param>
        /// <param name="version_number">The version number of the inline comment to be returned.</param>
        /// <returns>Returned if the requested version details are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DetailedVersion> GetInlineCommentVersionDetailsAsync(long id, long version_number, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            if (version_number == null)
                throw new System.ArgumentNullException("version_number");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "inline-comments/{id}/versions/{version-number}"
                    urlBuilder_.Append("inline-comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/versions/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(version_number, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DetailedVersion>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the specified page\nor blog post, the inline comment was not found, or the version number does not exist.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content properties for comment
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties attached to a specified comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response97> GetCommentContentPropertiesAsync(long comment_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit)
        {
            return GetCommentContentPropertiesAsync(comment_id, key, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content properties for comment
        /// </summary>
        /// <remarks>
        /// Retrieves Content Properties attached to a specified comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment for which content properties should be returned.</param>
        /// <param name="key">Filters the response to return a specific content property with matching key (case sensitive).</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of attachments per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested content properties are successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response97> GetCommentContentPropertiesAsync(long comment_id, string key, ContentPropertySortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "comments/{comment-id}/properties"
                    urlBuilder_.Append("comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");
                    urlBuilder_.Append('?');
                    if (key != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("key")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(key, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response97>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create content property for comment
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> CreateCommentPropertyAsync(long comment_id, ContentPropertyCreateRequest body)
        {
            return CreateCommentPropertyAsync(comment_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create content property for comment
        /// </summary>
        /// <remarks>
        /// Creates a new content property for a comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to update the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment to create a property for.</param>
        /// <param name="body">The content property to be created</param>
        /// <returns>Returned if the content property was created successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> CreateCommentPropertyAsync(long comment_id, ContentPropertyCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "comments/{comment-id}/properties"
                    urlBuilder_.Append("comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get content property for comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> GetCommentContentPropertiesByIdAsync(long comment_id, long property_id)
        {
            return GetCommentContentPropertiesByIdAsync(comment_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get content property for comment by id
        /// </summary>
        /// <remarks>
        /// Retrieves a specific Content Property by ID that is attached to a specified comment.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment for which content properties should be returned.</param>
        /// <param name="property_id">The ID of the content property being requested.</param>
        /// <returns>Returned if the requested content property is successfully retrieved.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> GetCommentContentPropertiesByIdAsync(long comment_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "comments/{comment-id}/properties/{property-id}"
                    urlBuilder_.Append("comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified comment, the comment was not found, or the property was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update content property for comment by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a comment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ContentProperty> UpdateCommentPropertyByIdAsync(long comment_id, long property_id, ContentPropertyUpdateRequest body)
        {
            return UpdateCommentPropertyByIdAsync(comment_id, property_id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update content property for comment by id
        /// </summary>
        /// <remarks>
        /// Update a content property for a comment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be updated.</param>
        /// <param name="body">The content property to be updated.</param>
        /// <returns>Returned if the content property was updated successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ContentProperty> UpdateCommentPropertyByIdAsync(long comment_id, long property_id, ContentPropertyUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "comments/{comment-id}/properties/{property-id}"
                    urlBuilder_.Append("comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ContentProperty>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete content property for comment by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a comment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteCommentPropertyByIdAsync(long comment_id, long property_id)
        {
            return DeleteCommentPropertyByIdAsync(comment_id, property_id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete content property for comment by id
        /// </summary>
        /// <remarks>
        /// Deletes a content property for a comment by its id. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the comment.
        /// </remarks>
        /// <param name="comment_id">The ID of the comment the property belongs to.</param>
        /// <param name="property_id">The ID of the property to be deleted.</param>
        /// <returns>Returned if the content property was deleted successfully.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteCommentPropertyByIdAsync(long comment_id, long property_id, System.Threading.CancellationToken cancellationToken)
        {
            if (comment_id == null)
                throw new System.ArgumentNullException("comment_id");

            if (property_id == null)
                throw new System.ArgumentNullException("property_id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "comments/{comment-id}/properties/{property-id}"
                    urlBuilder_.Append("comments/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(comment_id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/properties/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(property_id, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified comment or the comment was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get tasks
        /// </summary>
        /// <remarks>
        /// Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only tasks that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="include_blank_tasks">Specifies whether to include blank tasks in the response. Defaults to `true`.</param>
        /// <param name="status">Filters on the status of the task.</param>
        /// <param name="task_id">Filters on task ID. Multiple IDs can be specified.</param>
        /// <param name="space_id">Filters on the space ID of the task. Multiple IDs can be specified.</param>
        /// <param name="page_id">Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.</param>
        /// <param name="blogpost_id">Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.</param>
        /// <param name="created_by">Filters on the Account ID of the user who created this task. Multiple IDs can be specified.</param>
        /// <param name="assigned_to">Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified.</param>
        /// <param name="completed_by">Filters on the Account ID of the user who completed this task. Multiple IDs can be specified.</param>
        /// <param name="created_at_from">Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="created_at_to">Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="due_at_from">Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="due_at_to">Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="completed_at_from">Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="completed_at_to">Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of tasks per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested tasks are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response98> GetTasksAsync(PrimaryBodyRepresentation? body_format, bool? include_blank_tasks, Status2? status, System.Collections.Generic.IEnumerable<long> task_id, System.Collections.Generic.IEnumerable<long> space_id, System.Collections.Generic.IEnumerable<long> page_id, System.Collections.Generic.IEnumerable<long> blogpost_id, System.Collections.Generic.IEnumerable<string> created_by, System.Collections.Generic.IEnumerable<string> assigned_to, System.Collections.Generic.IEnumerable<string> completed_by, long? created_at_from, long? created_at_to, long? due_at_from, long? due_at_to, long? completed_at_from, long? completed_at_to, string cursor, int? limit)
        {
            return GetTasksAsync(body_format, include_blank_tasks, status, task_id, space_id, page_id, blogpost_id, created_by, assigned_to, completed_by, created_at_from, created_at_to, due_at_from, due_at_to, completed_at_from, completed_at_to, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get tasks
        /// </summary>
        /// <remarks>
        /// Returns all tasks. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only tasks that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <param name="include_blank_tasks">Specifies whether to include blank tasks in the response. Defaults to `true`.</param>
        /// <param name="status">Filters on the status of the task.</param>
        /// <param name="task_id">Filters on task ID. Multiple IDs can be specified.</param>
        /// <param name="space_id">Filters on the space ID of the task. Multiple IDs can be specified.</param>
        /// <param name="page_id">Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.</param>
        /// <param name="blogpost_id">Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.</param>
        /// <param name="created_by">Filters on the Account ID of the user who created this task. Multiple IDs can be specified.</param>
        /// <param name="assigned_to">Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified.</param>
        /// <param name="completed_by">Filters on the Account ID of the user who completed this task. Multiple IDs can be specified.</param>
        /// <param name="created_at_from">Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="created_at_to">Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="due_at_from">Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="due_at_to">Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="completed_at_from">Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="completed_at_to">Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of tasks per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested tasks are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response98> GetTasksAsync(PrimaryBodyRepresentation? body_format, bool? include_blank_tasks, Status2? status, System.Collections.Generic.IEnumerable<long> task_id, System.Collections.Generic.IEnumerable<long> space_id, System.Collections.Generic.IEnumerable<long> page_id, System.Collections.Generic.IEnumerable<long> blogpost_id, System.Collections.Generic.IEnumerable<string> created_by, System.Collections.Generic.IEnumerable<string> assigned_to, System.Collections.Generic.IEnumerable<string> completed_by, long? created_at_from, long? created_at_to, long? due_at_from, long? due_at_to, long? completed_at_from, long? completed_at_to, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks"
                    urlBuilder_.Append("tasks");
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (include_blank_tasks != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("include-blank-tasks")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(include_blank_tasks, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (task_id != null)
                    {
                        foreach (var item_ in task_id) { urlBuilder_.Append(System.Uri.EscapeDataString("task-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (space_id != null)
                    {
                        foreach (var item_ in space_id) { urlBuilder_.Append(System.Uri.EscapeDataString("space-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (page_id != null)
                    {
                        foreach (var item_ in page_id) { urlBuilder_.Append(System.Uri.EscapeDataString("page-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (blogpost_id != null)
                    {
                        foreach (var item_ in blogpost_id) { urlBuilder_.Append(System.Uri.EscapeDataString("blogpost-id")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (created_by != null)
                    {
                        foreach (var item_ in created_by) { urlBuilder_.Append(System.Uri.EscapeDataString("created-by")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (assigned_to != null)
                    {
                        foreach (var item_ in assigned_to) { urlBuilder_.Append(System.Uri.EscapeDataString("assigned-to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (completed_by != null)
                    {
                        foreach (var item_ in completed_by) { urlBuilder_.Append(System.Uri.EscapeDataString("completed-by")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (created_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("created-at-from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(created_at_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (created_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("created-at-to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(created_at_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (due_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("due-at-from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(due_at_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (due_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("due-at-to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(due_at_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (completed_at_from != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("completed-at-from")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(completed_at_from, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (completed_at_to != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("completed-at-to")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(completed_at_to, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response98>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get task by id
        /// </summary>
        /// <remarks>
        /// Returns a specific task. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the containing page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the task to be returned. If you don't know the task ID, use Get tasks and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <returns>Returned if the requested task is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ConfluenceTask> GetTaskByIdAsync(long id, PrimaryBodyRepresentation? body_format)
        {
            return GetTaskByIdAsync(id, body_format, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get task by id
        /// </summary>
        /// <remarks>
        /// Returns a specific task. 
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to view the containing page or blog post and its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the task to be returned. If you don't know the task ID, use Get tasks and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <returns>Returned if the requested task is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ConfluenceTask> GetTaskByIdAsync(long id, PrimaryBodyRepresentation? body_format, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks/{id}"
                    urlBuilder_.Append("tasks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ConfluenceTask>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nrequested task or the task was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update task
        /// </summary>
        /// <remarks>
        /// Update a task by id. This endpoint currently only supports updating task status.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the containing page or blog post and view its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the task to be updated. If you don't know the task ID, use Get tasks and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <returns>Returned if the requested task is updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ConfluenceTask> UpdateTaskAsync(long id, PrimaryBodyRepresentation? body_format, object body)
        {
            return UpdateTaskAsync(id, body_format, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update task
        /// </summary>
        /// <remarks>
        /// Update a task by id. This endpoint currently only supports updating task status.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to edit the containing page or blog post and view its corresponding space.
        /// </remarks>
        /// <param name="id">The ID of the task to be updated. If you don't know the task ID, use Get tasks and filter the results.</param>
        /// <param name="body_format">The content format types to be returned in the `body` field of the response. If available, the representation will be available under a response field of the same name under the `body` field.</param>
        /// <returns>Returned if the requested task is updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ConfluenceTask> UpdateTaskAsync(long id, PrimaryBodyRepresentation? body_format, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "tasks/{id}"
                    urlBuilder_.Append("tasks/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append('?');
                    if (body_format != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("body-format")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(body_format, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ConfluenceTask>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing from the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- The provided task does not exist\n- The user does not have permissions to view the task\n- The user does not have the needed permissions to update the containing page or blog post in the corresponding space", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get child pages
        /// </summary>
        /// <remarks>
        /// Returns all child pages for given page id. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent page. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested child pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual System.Threading.Tasks.Task<Response99> GetChildPagesAsync(long id, string cursor, int? limit, string sort)
        {
            return GetChildPagesAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get child pages
        /// </summary>
        /// <remarks>
        /// Returns all child pages for given page id. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only pages that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent page. If you don't know the page ID, use Get pages and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested child pages are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        [System.Obsolete]
        public virtual async System.Threading.Tasks.Task<Response99> GetChildPagesAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/children"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response99>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get child custom content
        /// </summary>
        /// <remarks>
        /// Returns all child custom content for given custom content id. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only custom content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent custom content. If you don't know the custom content ID, use Get custom-content and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested child custom content are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response100> GetChildCustomContentAsync(long id, string cursor, int? limit, string sort)
        {
            return GetChildCustomContentAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get child custom content
        /// </summary>
        /// <remarks>
        /// Returns all child custom content for given custom content id. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only custom content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent custom content. If you don't know the custom content ID, use Get custom-content and filter the results.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested child custom content are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response100> GetChildCustomContentAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "custom-content/{id}/children"
                    urlBuilder_.Append("custom-content/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response100>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get direct children of a page
        /// </summary>
        /// <remarks>
        /// Returns all children for given page id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent page.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response101> GetPageDirectChildrenAsync(long id, string cursor, int? limit, string sort)
        {
            return GetPageDirectChildrenAsync(id, cursor, limit, sort, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get direct children of a page
        /// </summary>
        /// <remarks>
        /// Returns all children for given page id in the content tree. The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each child. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only content that the user has permission to view will be returned.
        /// </remarks>
        /// <param name="id">The ID of the parent page.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, use the `Link` header to retrieve a relative URL that will return the next set of results.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <returns>Returned if the requested children are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response101> GetPageDirectChildrenAsync(long id, string cursor, int? limit, string sort, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/direct-children"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/direct-children");
                    urlBuilder_.Append('?');
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response101>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get all ancestors of page
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given page by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <param name="id">The ID of the page.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, call this endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response102> GetPageAncestorsAsync(long id, int? limit)
        {
            return GetPageAncestorsAsync(id, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get all ancestors of page
        /// </summary>
        /// <remarks>
        /// Returns all ancestors for a given page by ID in top-to-bottom order (that is, the highest ancestor is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the ID of first ancestor in the response payload.
        /// <br/>
        /// <br/>This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such
        /// <br/>as [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <param name="id">The ID of the page.</param>
        /// <param name="limit">Maximum number of pages per result to return. If more results exist, call this endpoint with the highest ancestor's ID to fetch the next set of results.</param>
        /// <returns>Returned if the requested ancestors are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response102> GetPageAncestorsAsync(long id, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/ancestors"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/ancestors");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response102>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get descendants of page
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given page by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the page and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the page.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response103> GetPageDescendantsAsync(long id, int? limit, int? depth, string cursor)
        {
            return GetPageDescendantsAsync(id, limit, depth, cursor, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get descendants of page
        /// </summary>
        /// <remarks>
        /// Returns descendants in the content tree for a given page by ID in top-to-bottom order (that is, the highest descendant is the first
        /// <br/>item in the response payload). The number of results is limited by the `limit` parameter and additional results (if available)
        /// <br/>will be available by calling this endpoint with the cursor in the response payload. There is also a `depth` parameter specifying depth
        /// <br/>of descendants to be fetched.
        /// <br/>
        /// <br/>The following types of content will be returned:
        /// <br/>- Database
        /// <br/>- Embed
        /// <br/>- Folder
        /// <br/>- Page
        /// <br/>- Whiteboard
        /// <br/>
        /// <br/>This endpoint returns minimal information about each descendant. To fetch more details, use a related endpoint based on the content type, such
        /// <br/>as:
        /// <br/>
        /// <br/>- [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get)
        /// <br/>- [Get embed by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get)
        /// <br/>- [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-folder/#api-folders-id-get)
        /// <br/>- [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get)
        /// <br/>- [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Permission to view the page and its corresponding space
        /// </remarks>
        /// <param name="id">The ID of the page.</param>
        /// <param name="limit">Maximum number of items per result to return. If more results exist, call the endpoint with the cursor to fetch the next set of results.</param>
        /// <param name="depth">Maximum depth of descendants to return. If more results are required, use the endpoint corresponding to the content type of the deepest descendant to fetch more descendants.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <returns>Returned if the requested descendants are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response103> GetPageDescendantsAsync(long id, int? limit, int? depth, string cursor, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/descendants"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/descendants");
                    urlBuilder_.Append('?');
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (depth != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("depth")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depth, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response103>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to view the\nspecified page or the page was not found.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Create bulk user lookup using ids
        /// </summary>
        /// <remarks>
        /// Returns user details for the ids provided in the request body.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>The user must be able to view user profiles in the Confluence site.
        /// </remarks>
        /// <returns>Returned if the user info is returned for the account IDs. `results` may be empty if no account IDs were found.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response104> CreateBulkUserLookupAsync(object body)
        {
            return CreateBulkUserLookupAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Create bulk user lookup using ids
        /// </summary>
        /// <remarks>
        /// Returns user details for the ids provided in the request body.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>The user must be able to view user profiles in the Confluence site.
        /// </remarks>
        /// <returns>Returned if the user info is returned for the account IDs. `results` may be empty if no account IDs were found.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response104> CreateBulkUserLookupAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "users-bulk"
                    urlBuilder_.Append("users-bulk");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response104>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to use Confluence or view user profiles.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Check site access for a list of emails
        /// </summary>
        /// <remarks>
        /// Returns the list of emails from the input list that do not have access to site.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returns object with list of emails without access to site.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response105> CheckAccessByEmailAsync(object body)
        {
            return CheckAccessByEmailAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Check site access for a list of emails
        /// </summary>
        /// <remarks>
        /// Returns the list of emails from the input list that do not have access to site.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returns object with list of emails without access to site.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response105> CheckAccessByEmailAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "user/access/check-access-by-email"
                    urlBuilder_.Append("user/access/check-access-by-email");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response105>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to check access for emails on site.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if API is disabled on site", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Invite a list of emails to the site
        /// </summary>
        /// <remarks>
        /// Invite a list of emails to the site.
        /// <br/>
        /// <br/>Ignores all invalid emails and no action is taken for the emails that already have access to the site.
        /// <br/>
        /// <br/>&lt;b&gt;NOTE:&lt;/b&gt; This API is asynchronous and may take some time to complete.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returns object with list of emails without access to site.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task InviteByEmailAsync(object body)
        {
            return InviteByEmailAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Invite a list of emails to the site
        /// </summary>
        /// <remarks>
        /// Invite a list of emails to the site.
        /// <br/>
        /// <br/>Ignores all invalid emails and no action is taken for the emails that already have access to the site.
        /// <br/>
        /// <br/>&lt;b&gt;NOTE:&lt;/b&gt; This API is asynchronous and may take some time to complete.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returns object with list of emails without access to site.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task InviteByEmailAsync(object body, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "user/access/invite-by-email"
                    urlBuilder_.Append("user/access/invite-by-email");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the calling user does not have permission to check access for emails on site.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if API is disabled on site", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get data policy metadata for the workspace
        /// </summary>
        /// <remarks>
        /// Returns data policy metadata for the workspace.
        /// <br/>
        /// <br/>**[Permissions](#permissions) required:**
        /// <br/>Only apps can make this request.
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returned if the request is successful.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DataPolicyMetadata> GetDataPolicyMetadataAsync()
        {
            return GetDataPolicyMetadataAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get data policy metadata for the workspace
        /// </summary>
        /// <remarks>
        /// Returns data policy metadata for the workspace.
        /// <br/>
        /// <br/>**[Permissions](#permissions) required:**
        /// <br/>Only apps can make this request.
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returned if the request is successful.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DataPolicyMetadata> GetDataPolicyMetadataAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "data-policies/metadata"
                    urlBuilder_.Append("data-policies/metadata");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DataPolicyMetadata>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the request is not valid.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get spaces with data policies
        /// </summary>
        /// <remarks>
        /// Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
        /// <br/>additional results (if available) will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Only apps can make this request.
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only spaces that the app has permission to view will be returned.
        /// </remarks>
        /// <param name="ids">Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="keys">Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested spaces are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response106> GetDataPolicySpacesAsync(System.Collections.Generic.IEnumerable<long> ids, System.Collections.Generic.IEnumerable<string> keys, SpaceSortOrder? sort, string cursor, int? limit)
        {
            return GetDataPolicySpacesAsync(ids, keys, sort, cursor, limit, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get spaces with data policies
        /// </summary>
        /// <remarks>
        /// Returns all spaces. The results will be sorted by id ascending. The number of results is limited by the `limit` parameter and
        /// <br/>additional results (if available) will be available through the `next` URL present in the `Link` response header.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>Only apps can make this request.
        /// <br/>Permission to access the Confluence site ('Can use' global permission).
        /// <br/>Only spaces that the app has permission to view will be returned.
        /// </remarks>
        /// <param name="ids">Filter the results to spaces based on their IDs. Multiple IDs can be specified as a comma-separated list.</param>
        /// <param name="keys">Filter the results to spaces based on their keys. Multiple keys can be specified as a comma-separated list.</param>
        /// <param name="sort">Used to sort the result by a particular field.</param>
        /// <param name="cursor">Used for pagination, this opaque cursor will be returned in the `next` URL in the `Link` response header. Use the relative URL in the `Link` header to retrieve the `next` set of results.</param>
        /// <param name="limit">Maximum number of spaces per result to return. If more results exist, use the `Link` response header to retrieve a relative URL that will return the next set of results.</param>
        /// <returns>Returned if the requested spaces are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response106> GetDataPolicySpacesAsync(System.Collections.Generic.IEnumerable<long> ids, System.Collections.Generic.IEnumerable<string> keys, SpaceSortOrder? sort, string cursor, int? limit, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "data-policies/spaces"
                    urlBuilder_.Append("data-policies/spaces");
                    urlBuilder_.Append('?');
                    if (ids != null)
                    {
                        foreach (var item_ in ids) { urlBuilder_.Append(System.Uri.EscapeDataString("ids")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (keys != null)
                    {
                        foreach (var item_ in keys) { urlBuilder_.Append(System.Uri.EscapeDataString("keys")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append('&'); }
                    }
                    if (sort != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("sort")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(sort, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cursor != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cursor")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cursor, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (limit != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("limit")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(limit, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response106>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get list of classification levels
        /// </summary>
        /// <remarks>
        /// Returns a list of [classification levels](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) 
        /// <br/>available.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returned if classifications levels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClassificationLevel>> GetClassificationLevelsAsync()
        {
            return GetClassificationLevelsAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get list of classification levels
        /// </summary>
        /// <remarks>
        /// Returns a list of [classification levels](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) 
        /// <br/>available.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission).
        /// </remarks>
        /// <returns>Returned if classifications levels are returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<System.Collections.Generic.ICollection<ClassificationLevel>> GetClassificationLevelsAsync(System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "classification-levels"
                    urlBuilder_.Append("classification-levels");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<System.Collections.Generic.ICollection<ClassificationLevel>>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Classification levels do not exist\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permissions to access the Confluence site\n", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get space default classification level
        /// </summary>
        /// <remarks>
        /// Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be returned.</param>
        /// <returns>Returned if the requested default classification level for a space is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClassificationLevel> GetSpaceDefaultClassificationLevelAsync(long id)
        {
            return GetSpaceDefaultClassificationLevelAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get space default classification level
        /// </summary>
        /// <remarks>
        /// Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be returned.</param>
        /// <returns>Returned if the requested default classification level for a space is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClassificationLevel> GetSpaceDefaultClassificationLevelAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/classification-level/default"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/default");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClassificationLevel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Default classification level is not applied to the space\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified space or the space was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update space default classification level
        /// </summary>
        /// <remarks>
        /// Update the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be updated.</param>
        /// <returns>Returned if the default classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutSpaceDefaultClassificationLevelAsync(long id, object body)
        {
            return PutSpaceDefaultClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update space default classification level
        /// </summary>
        /// <remarks>
        /// Update the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be updated.</param>
        /// <returns>Returned if the default classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutSpaceDefaultClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/classification-level/default"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/default");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified space or the space was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Delete space default classification level
        /// </summary>
        /// <remarks>
        /// Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be deleted.</param>
        /// <returns>Returned if the default classification level was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteSpaceDefaultClassificationLevelAsync(long id)
        {
            return DeleteSpaceDefaultClassificationLevelAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Delete space default classification level
        /// </summary>
        /// <remarks>
        /// Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/) 
        /// <br/>for a specific space.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and 'Admin' permission for the space.
        /// </remarks>
        /// <param name="id">The ID of the space for which default classification level should be deleted.</param>
        /// <returns>Returned if the default classification level was successfully deleted.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteSpaceDefaultClassificationLevelAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "spaces/{id}/classification-level/default"
                    urlBuilder_.Append("spaces/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/default");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified space or the space was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get page classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
        /// <br/>'Permission to edit the page is required if trying to view classification level for a draft.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be returned.</param>
        /// <param name="status">Status of page from which classification level will fetched.</param>
        /// <returns>Returned if the requested classification level for a page is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClassificationLevel> GetPageClassificationLevelAsync(long id, Status3? status)
        {
            return GetPageClassificationLevelAsync(id, status, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get page classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
        /// <br/>'Permission to edit the page is required if trying to view classification level for a draft.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be returned.</param>
        /// <param name="status">Status of page from which classification level will fetched.</param>
        /// <returns>Returned if the requested classification level for a page is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClassificationLevel> GetPageClassificationLevelAsync(long id, Status3? status, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/classification-level"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");
                    urlBuilder_.Append('?');
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClassificationLevel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Page does not have a classification level applied\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified page or the page was not found\n- The calling user does not have permission to edit the specified page when trying to fetch classification level for a draft", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update page classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the page.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutPageClassificationLevelAsync(long id, object body)
        {
            return PutPageClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update page classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the page.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutPageClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/classification-level"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified page or the page was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset page classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PostPageClassificationLevelAsync(long id, object body)
        {
            return PostPageClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset page classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific page for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the page.
        /// </remarks>
        /// <param name="id">The ID of the page for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostPageClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "pages/{id}/classification-level/reset"
                    urlBuilder_.Append("pages/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/reset");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified page or the page was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get blog post classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
        /// <br/>'Permission to edit the blog post is required if trying to view classification level for a draft.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be returned.</param>
        /// <param name="status">Status of blog post from which classification level will fetched.</param>
        /// <returns>Returned if the requested classification level for a blog post is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClassificationLevel> GetBlogPostClassificationLevelAsync(long id, Status4? status)
        {
            return GetBlogPostClassificationLevelAsync(id, status, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get blog post classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
        /// <br/>'Permission to edit the blog post is required if trying to view classification level for a draft.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be returned.</param>
        /// <param name="status">Status of blog post from which classification level will fetched.</param>
        /// <returns>Returned if the requested classification level for a blog post is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClassificationLevel> GetBlogPostClassificationLevelAsync(long id, Status4? status, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/classification-level"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");
                    urlBuilder_.Append('?');
                    if (status != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("status")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(status, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClassificationLevel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Blog post does not have a classification level applied\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified blog post or the blog post was not found\n- The calling user does not have permission to edit the specified blog post when trying to fetch classification level for a draft", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update blog post classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the blog post.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutBlogPostClassificationLevelAsync(long id, object body)
        {
            return PutBlogPostClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update blog post classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the blog post.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutBlogPostClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/classification-level"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified blog post or the blog post was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset blog post classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post for the space  
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PostBlogPostClassificationLevelAsync(long id, object body)
        {
            return PostBlogPostClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset blog post classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific blog post for the space  
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the blog post.
        /// </remarks>
        /// <param name="id">The ID of the blog post for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostBlogPostClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "blogposts/{id}/classification-level/reset"
                    urlBuilder_.Append("blogposts/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/reset");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified blog post or the blog post was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be returned.</param>
        /// <returns>Returned if the requested classification level for a whiteboard is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClassificationLevel> GetWhiteboardClassificationLevelAsync(long id)
        {
            return GetWhiteboardClassificationLevelAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be returned.</param>
        /// <returns>Returned if the requested classification level for a whiteboard is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClassificationLevel> GetWhiteboardClassificationLevelAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/classification-level"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClassificationLevel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Whiteboard does not have a classification level applied\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified whiteboard, or the whiteboard was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutWhiteboardClassificationLevelAsync(long id, object body)
        {
            return PutWhiteboardClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutWhiteboardClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/classification-level"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified whiteboard\n- The whiteboard or classification level was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PostWhiteboardClassificationLevelAsync(long id, object body)
        {
            return PostWhiteboardClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset whiteboard classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific whiteboard for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the whiteboard.
        /// </remarks>
        /// <param name="id">The ID of the whiteboard for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostWhiteboardClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "whiteboards/{id}/classification-level/reset"
                    urlBuilder_.Append("whiteboards/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/reset");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified whiteboard, or the whiteboard was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get database classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be returned.</param>
        /// <returns>Returned if the requested classification level for a database is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClassificationLevel> GetDatabaseClassificationLevelAsync(long id)
        {
            return GetDatabaseClassificationLevelAsync(id, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get database classification level
        /// </summary>
        /// <remarks>
        /// Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be returned.</param>
        /// <returns>Returned if the requested classification level for a database is returned.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClassificationLevel> GetDatabaseClassificationLevelAsync(long id, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/classification-level"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClassificationLevel>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Database does not have a classification level applied\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to view the specified database, or the database was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Update database classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PutDatabaseClassificationLevelAsync(long id, object body)
        {
            return PutDatabaseClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Update database classification level
        /// </summary>
        /// <remarks>
        /// Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database.
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to edit the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully updated.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PutDatabaseClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/classification-level"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified database\n- The database or the classification level was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Reset database classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task PostDatabaseClassificationLevelAsync(long id, object body)
        {
            return PostDatabaseClassificationLevelAsync(id, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Reset database classification level
        /// </summary>
        /// <remarks>
        /// Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)
        /// <br/>for a specific database for the space 
        /// <br/>[default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).
        /// <br/>
        /// <br/>**[Permissions](https://confluence.atlassian.com/x/_AozKw) required**:
        /// <br/>'Permission to access the Confluence site ('Can use' global permission) and permission to view the database.
        /// </remarks>
        /// <param name="id">The ID of the database for which classification level should be updated.</param>
        /// <returns>Returned if the classification level was successfully reset.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task PostDatabaseClassificationLevelAsync(long id, object body, System.Threading.CancellationToken cancellationToken)
        {
            if (id == null)
                throw new System.ArgumentNullException("id");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = await CreateHttpRequestMessageAsync(cancellationToken).ConfigureAwait(false))
                {
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "databases/{id}/classification-level/reset"
                    urlBuilder_.Append("databases/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(id, System.Globalization.CultureInfo.InvariantCulture)));
                    urlBuilder_.Append("/classification-level/reset");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if an invalid request is provided.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 401)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if the authentication credentials are incorrect or missing\nfrom the request.", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Returned if:\n- Site\'s edition does not have entitlement(s) for [data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)\n- The calling user does not have permission to edit the specified database, or the database was not found", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625